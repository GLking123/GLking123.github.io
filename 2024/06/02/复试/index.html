<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>复试 | LeiLeiBear</title><meta name="author" content="Lei Lei"><meta name="copyright" content="Lei Lei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="计算机网络多路复用技术：若干个彼此独立的信号，合并为一个可以在同一个信道上同时 传输和复合 信号的方法。&#x20; 频分多路复用：用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带，所有用户在同样的时间占用不同的带宽资源。 时分多路复用：所有用户在不同的时间占用同样的频带宽度。 (识数)。 波分复用：用一根光纤来同时传输多个频率很接近的光载波信号。&#x20; 码分多路复用：每一个用户">
<meta property="og:type" content="article">
<meta property="og:title" content="复试">
<meta property="og:url" content="https://glking123.github.io/2024/06/02/%E5%A4%8D%E8%AF%95/index.html">
<meta property="og:site_name" content="LeiLeiBear">
<meta property="og:description" content="计算机网络多路复用技术：若干个彼此独立的信号，合并为一个可以在同一个信道上同时 传输和复合 信号的方法。&#x20; 频分多路复用：用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带，所有用户在同样的时间占用不同的带宽资源。 时分多路复用：所有用户在不同的时间占用同样的频带宽度。 (识数)。 波分复用：用一根光纤来同时传输多个频率很接近的光载波信号。&#x20; 码分多路复用：每一个用户">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://glking123.github.io/img/touxiang.jpg">
<meta property="article:published_time" content="2024-06-02T03:20:52.000Z">
<meta property="article:modified_time" content="2024-06-02T03:31:51.464Z">
<meta property="article:author" content="Lei Lei">
<meta property="article:tag" content="计算机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://glking123.github.io/img/touxiang.jpg"><link rel="shortcut icon" href="/img/animal.png"><link rel="canonical" href="https://glking123.github.io/2024/06/02/%E5%A4%8D%E8%AF%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '复试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-02 11:31:51'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/head_1.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 热爱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="LeiLeiBear"><img class="site-icon" src="/img/animal.png"/><span class="site-name">LeiLeiBear</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 热爱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">复试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-02T03:20:52.000Z" title="发表于 2024-06-02 11:20:52">2024-06-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-02T03:31:51.464Z" title="更新于 2024-06-02 11:31:51">2024-06-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="复试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="多路复用技术："><a href="#多路复用技术：" class="headerlink" title="多路复用技术："></a><strong>多路复用技术：</strong></h3><p>若干个彼此独立的信号，合并为一个可以在同一个信道上同时 传输和复合 信号的方法。&#x20;</p>
<p>频分多路复用：用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带，所有用户在同样的时间占用不同的带宽资源。</p>
<p>时分多路复用：所有用户在不同的时间占用同样的频带宽度。 (识数)。</p>
<p>波分复用：用一根光纤来同时传输多个频率很接近的光载波信号。&#x20;</p>
<p>码分多路复用：每一个用户可以在同样的时间使用同样的频带进行通信，靠不同的编码来区分各路原始信号的一种复用技术。&#x20;</p>
<h3 id="TCP-IP-的核心思想："><a href="#TCP-IP-的核心思想：" class="headerlink" title="TCP&#x2F;IP 的核心思想："></a><strong>TCP&#x2F;IP 的核心思想：</strong></h3><p>TCP&#x2F;IP 的核心思想是“网络互联”，将使用不同低层次协议的异构网络，在运输 层、 网络层建立一个统一的虚拟逻辑网络。&#x20;</p>
<h3 id="电路交换："><a href="#电路交换：" class="headerlink" title="电路交换："></a><strong>电路交换：</strong></h3><p>在发送数据之间嘛，建立一个全双工，<strong>双方独占的物理链路</strong>。</p>
<p>优点：传播时延小，实时性高，全双工链路不会发生冲突，数据有序到达，适用模拟与数字信号。</p>
<p>缺点：需要建立数据链路的时延，链路利用率低， 数据直达 导致不同类型 不同规格 不同速率的终端难以进行互通，灵活性差 如果有一个节点发生故障就会影响。</p>
<h3 id="报文交换："><a href="#报文交换：" class="headerlink" title="报文交换："></a><strong>报文交换：</strong></h3><p>数据交换的单位是报文，报文携带源地址，目的地址。采用<strong>存储转发。</strong></p>
<p>优点：无需建立连接，动态分配线路，线路的利用率高，一对多。</p>
<p>缺点：只适用于数字信号（文殊），实时性差，要求每个网络节点有大的缓冲区。</p>
<h3 id="分组转发："><a href="#分组转发：" class="headerlink" title="分组转发："></a><strong>分组转发：</strong></h3><p>优点：加速传输 流水线，简化存储管理 ，分组短小 适合突发式传输。</p>
<p>缺点：存在传输时延，分数使用<strong>数据报服务</strong>时 存在分组 丢失 乱序 分组到达目的地还需要按照需要进行排序。<strong>虚电路服务</strong>时，需要建立连接。</p>
<h3 id="网络协议："><a href="#网络协议：" class="headerlink" title="网络协议："></a><strong>网络协议：</strong></h3><p>语法，语义，同步。</p>
<h3 id="RARP协议的工作过程"><a href="#RARP协议的工作过程" class="headerlink" title="RARP协议的工作过程"></a>RARP协议的工作过程</h3><p>1 主机发送一个<strong>本地RARP广播</strong>，在广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址。</p>
<p>2 本地网段的RARP服务器收到此请求后，检查器RARP列表，查找该MAC地址对应的IP地址。</p>
<p>3 如果存在，RARP服务器就给源主机发送一个响应数据包，并将IP地址提供给对方主机使用。</p>
<p>4 如果不存在，RARP服务器对此不做任何响应。</p>
<p>5 源主机收到从RARP服务的响应信息，就利用得到的IP地址进行通信。如果一直没收到RARA服务器的响应信息，表示初始化失败。</p>
<h3 id="为什么三次握手："><a href="#为什么三次握手：" class="headerlink" title="为什么三次握手："></a><strong>为什么三次握手：</strong></h3><p>三次握手的本质是<strong>确认通信双方收发数据的能力</strong>.</p>
<p>建立可靠的通信链路，防止报文段在传输连接建立的过程中出错。</p>
<p><img src="/"></p>
<h3 id="为什么四次挥手："><a href="#为什么四次挥手：" class="headerlink" title="为什么四次挥手："></a><strong>为什么四次挥手：</strong></h3><p>tcp是全双工通信。</p>
<p>保证最后一个ACK报文能过够到达服务器，</p>
<p>在2MSL的时间中，所有失效的报文段都消失。</p>
<p><img src="/"></p>
<p>UMI:统一资源标识符，唯一标识一个资源 (身份证)</p>
<p>UML:<strong>统一资源定位符</strong>，提供资源路径（家庭住址）</p>
<h3 id="何理解同步和异步？什么是同步通信和异步通信？-x20"><a href="#何理解同步和异步？什么是同步通信和异步通信？-x20" class="headerlink" title="何理解同步和异步？什么是同步通信和异步通信？&#x20;"></a><strong>何理解同步和异步？什么是同步通信和异步通信？</strong>&#x20;</h3><p><strong>同步通信</strong>的<strong>通信双方必须先建立同步</strong>， 即<strong>双方的时钟要调整到同一个频率</strong>。<strong>收发双方不停地</strong></p>
<p><strong>发送和接收连续的同步比特流</strong>。</p>
<p><strong>异步通信</strong>在<strong>发送字符</strong>时，<strong>所发送的字符之间的时间间隔可以是任意的，</strong>但<strong>接收端必须时刻做</strong></p>
<p><strong>好接收的准备</strong>。<strong>发送端可以在任意时刻开始发送字符</strong>， 因此必须在每个<strong>字符开始</strong>和<strong>结束的地方</strong>加</p>
<p>上标志， 即<strong>开始位和停止位</strong>，以<strong>便使接收端能够正确地将每个字符接收下来</strong>。异步通信也可以<strong>帧</strong></p>
<p>作为发送的单位。</p>
<h3 id="流量控制的方式："><a href="#流量控制的方式：" class="headerlink" title="流量控制的方式："></a>流量控制的方式：</h3><ul>
<li><strong>停止-等待流量控制方式基本原理(发送窗口大小&#x3D;1，接受窗口大小&#x3D;1）</strong></li>
</ul>
<p><strong>发送方每发送一帧，都要等待接收方的应答信号，之后才能发送下一帧</strong>；如果<strong>接收方不反馈应答信号，那么发送方必须一直等待</strong>。每次只允许发送一帧，然后就陷入等待接收方确认信息的过程中，因而传输效率很低。</p>
<ul>
<li>滑动窗口流量控制方式基本原理</li>
</ul>
<p><strong>在任意时刻</strong>，发送方<strong>都维持一组连续的允许发送的帧的序号</strong>，称为<strong>发送窗口</strong>；同时<strong>接收方也维持</strong></p>
<p><strong>一组连续的允许接收帧的序号</strong>，称为<strong>接收窗口</strong>。发送窗口用来对发送方进行流量控制，而发送窗</p>
<p>口的大小代表在还未收到对方确认信息的情况下发送方最多还可以发送多少个数据帧。同理，在</p>
<p>接收端设置接收窗口是为了控制可以接收哪些数据帧和不可以接收哪些帧。在接收方，只有收到</p>
<p>的数据帧的序号落入接收窗口内时，才允许将该数据帧收下。若接收到的数据帧落在接收窗口之</p>
<p>外，则一律将其丢弃。</p>
<ul>
<li><strong>后退N帧协议（GBN）（发送窗口大小&gt;1,接收窗口大小&#x3D;1）</strong></li>
</ul>
<p><strong>累计确认</strong></p>
<p>在后退N 帧式ARQ 中，<strong>发送方无须在收到上一个帧的ACK 后才能开始发送下一帧，而是可以连续</strong></p>
<p><strong>发送帧</strong>。当接收方检测出<strong>失序的信息帧</strong>后，要求发送方重发最后一个正确接收的信息帧之后的所</p>
<p>有未被确认的帧；或者当发送方发送了N 个帧后，若发现该N 个帧的前一个帧在<strong>计时器超时</strong>后仍</p>
<p>未返回其确认信息，则该帧被判为出错或丢失，此时<strong>发送方就不得不重传该出错帧及随后的N 个</strong></p>
<p><strong>帧</strong>。换句话说，接收方只允许按顺序接收帧。（<strong>接收窗口大小&#x3D;1则按序接收</strong>）</p>
<ul>
<li><strong>选择重传协议（SR）（发送窗口大小&gt;1,接收窗口大小&gt;1)</strong></li>
</ul>
<p><strong>逐一确认</strong>选择重传协议中，每个发送缓冲区对应一个计时器，当计时器超时时，缓冲区的帧就会重传。只传<strong>出错帧</strong></p>
<p>另外，该协议使用了比上述其他协议更有效的差错处理策略，即一旦接收方怀疑帧出错，就会发</p>
<p>一个否定帧NAK给发送方，要求发送方对NAK中指定的帧进行重传。</p>
<h3 id="为什么每台主机都分配唯一的IP地址了，为什么还要在网络设备（如网卡，集线器，路由器等）生产时内嵌一个唯一的MAC地址呢？主要原因有以下几点："><a href="#为什么每台主机都分配唯一的IP地址了，为什么还要在网络设备（如网卡，集线器，路由器等）生产时内嵌一个唯一的MAC地址呢？主要原因有以下几点：" class="headerlink" title="为什么每台主机都分配唯一的IP地址了，为什么还要在网络设备（如网卡，集线器，路由器等）生产时内嵌一个唯一的MAC地址呢？主要原因有以下几点："></a>为什么每台主机都分配唯一的IP地址了，为什么还要在网络设备（如网卡，集线器，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%B7%AF%E7%94%B1%E5%99%A8&spm=1001.2101.3001.7020">路由器</a>等）生产时内嵌一个唯一的MAC地址呢？主要原因有以下几点：</h3><p>（1）<strong>IP地址是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BD%91%E7%BB%9C%E5%B1%82&spm=1001.2101.3001.7020">网络层</a>使用的地址</strong>，其分配根据的是网络的拓朴结构，它<strong>能唯一地确定一台主机在网络中的位置</strong>，另外<strong>它有一种办法来区分不同的网络</strong>；<strong>MAC地址是数据链路层使用的地址</strong>，它也能唯一地确定一台主机在网络中的位置。<strong>但是它没有一种办法很好地区分不同的网络</strong>。</p>
<p>（2）<strong>将IP地址和mac地址分离</strong>，使得<strong>网络地址的管理更加的灵活</strong>，使得<strong>逻辑地址和物理地址充分解耦</strong>。如果一个<strong>以太网卡坏了</strong>，可以被更换，而<strong>无须取得一个新的IP地址</strong>。如果<strong>一个IP主机从一个网络移到另一个网络</strong>，可以给它一个新的IP地址，而<strong>无须换一个新的网卡</strong>。</p>
<p>（3）<strong>数据包</strong>在<strong>节点之间</strong>的移动都是<strong>根据MAC地址进行的</strong>，由<strong>ARP</strong>负责将<strong>IP地址映射到MAC地址。</strong></p>
<p>（4）全世界存在着各种各样的网络，他们使用不同的硬件地址，要让这些网络能够互相通信就需要非常复杂的硬件转换工作，让用户和用户主机来完成这项工作几乎不可能。但是，统一的IP地址就可以将这个复杂的问题完全解决。就像联通一个网络一样方便，地址转换由ARP自动进行，十分方便。</p>
<h2 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a><strong>数据结</strong>构：</h2><p>数据结构：数据与数据之间的结构关系（数组、队列、树、图等结构）</p>
<p>算法：解决问题的步骤。</p>
<p>程序 &#x3D; 数据结构 + 算法</p>
<p>数据结构是底层，算法高层。数据结构为算法提供服务。算法围绕数据结构操作。</p>
<h3 id="数据结构具体有哪几种吗？"><a href="#数据结构具体有哪几种吗？" class="headerlink" title="数据结构具体有哪几种吗？"></a>数据结构具体有哪几种吗？</h3><ol>
<li><p>数据的<strong>逻辑结构</strong>，指反映数据元素之间的逻辑关系的数据结构，其中的逻辑关系是指<strong>数据元素之间的前后间关系</strong>，而与他们在计算机中的存储位置无关。</p>
</li>
<li><p>数据的<strong>物理结构</strong>，指<strong>数据的逻辑结构在计算机存储空间的存放形式</strong>。数据的物理结构是数据结构在计算机中的表示（又称映像），它包括数据元素的机内表示和关系的机内表示。由于具体实现的方法有<strong>顺序、链式、索引、散列等多种</strong>，所以，一种数据结构可表示成一种或多种存储结构。</p>
</li>
</ol>
<h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><p><strong>栈与队列的相同点：</strong></p>
<ol>
<li><p>都是线性结构。</p>
</li>
<li><p>插入操作都是限定在表尾进行。</p>
</li>
</ol>
<ol start="3">
<li>插入与删除的时间复杂度都是 O(1)，在空间复杂度两者相同。</li>
</ol>
<p><strong>栈与队列的不同点：</strong></p>
<p>①删除数据元素的位置不同，栈的删除操作在表尾进行，队列的删除操作在表头</p>
<p>进行。</p>
<p>②应用场景不同，常见栈的应用场景包括括号问题的求解，表达式的转换和求值，</p>
<p>函数调用和递归实现，深度优先搜索遍历；常见的队列的应用场景广度优先搜索遍历。</p>
<p><strong>队列假溢出</strong></p>
<p>队列假溢出现象是指队列中还有剩余空间但元素却不能进入队列,这种现象是由于队列的设计不合理所致。</p>
<p><strong>后缀表达式求值的算法思想</strong></p>
<p>①如果是操作数,则进栈</p>
<p>②如果是运算符，则从栈中退出两个元素,进行出栈,且将得到的结果入栈</p>
<p>③表达式的所有项都扫描完后，后栈顶存放的元素就是最终的结果</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p><strong>满二叉树：</strong></p>
<p>①高度为 H，结点数为 （2^H）-1的二叉树为满二叉树。</p>
<p>②<strong>满二叉树一定是完全二叉树。</strong></p>
<p><strong>完全二叉树：</strong></p>
<p>①<strong>除最后一层外，其余各层的节点数量达到最大值，并且最后一层只能在右侧缺</strong></p>
<p><strong>少节点。</strong></p>
<p>②若有度为 1的结点，则只可能有一个，且<strong>该结点只有左孩子而无右孩子</strong>。</p>
<p><strong>二叉排序树：</strong></p>
<p>①左子树上所有的关键字均小于根结点，右子树上所有关键字均大于根结点。左</p>
<p>子树和右子树又分别是一棵二叉排序树。</p>
<p>②构造二叉排序树时，用两组相同的数据，若数据的排列顺序不同，构造出的二</p>
<p>叉排序树也不一样。</p>
<p>③二叉排序树的叶子结点到根结点的路径<strong>不一定是有序的</strong>。</p>
<p><strong>平衡二叉树：</strong>树中每一个结点的<strong>左子树，右子树高度之差的绝对值小于等于 1。</strong></p>
<p><strong>哈夫曼树：</strong></p>
<p>哈夫曼树：<strong>带权路径长度最小</strong>的树为哈夫曼树</p>
<p>权：树中的结点往往被赋予一个有意义的数值称为该结点的权。</p>
<p>结点的带权路径长度：从树的根到任意节点的<strong>路径长度</strong>与<strong>该结点的权值之积</strong>称为</p>
<p>该结点的带权路径长度。</p>
<p>树的带权路径长度：<strong>树中所有叶结点</strong>的<strong>带权路径之和</strong>为该树的带权路径长度。</p>
<p><strong>树的存储结构：</strong></p>
<p>双亲表示法：采用的<strong>一组连续的存储空间</strong>来存储每个节点。（顺序存储）</p>
<p><img src="/"></p>
<p>孩子表示法：将每个节点的孩子节点都用<strong>单链表连接起来形成一个线性结构</strong>，n个节点具有n个孩子链表。（多重链表）</p>
<p><img src="/"></p>
<p>孩子兄弟表示法：以<strong>二叉链表</strong>作为树的存储结构</p>
<p><img src="/"></p>
<p><strong>树转二叉树：左孩子右兄弟</strong></p>
<p><strong>树         森林       二叉树</strong></p>
<p><strong>先根    先序        先序</strong></p>
<p><strong>后根    中序       中序</strong></p>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p><strong>图的存储：</strong></p>
<p>邻接矩阵：适合稠密图</p>
<p>邻接表：适合稀疏图</p>
<p>十字链表法：适合有向图</p>
<p>邻接多重表：只适合无向图</p>
<p><strong>AOV网与AOE网？</strong></p>
<p>AOV网(有向无环图):<strong>顶点</strong>用来表示<strong>活动</strong>。AOV网的<strong>边无权值</strong>，仅表示顶点的前后关系。</p>
<p>AOE网(带权有向图):顶点表示<strong>事件</strong>，<strong>边表示活动</strong>，边上的权值用来表示<strong>活动持续的时间</strong>。AOE网是用来表示活动之间的制约关系。</p>
<p><strong>最小生成树 ：</strong></p>
<p>Prim算法：随机从一个顶点出发，每次的最小权值纳入生成树，直到完成。（稠密图）</p>
<p>kruskal算法:每次选择一个最小的边，是这两个边两头连通，如果连通过就不选，直至完成（稀疏图）</p>
<p>贪心算法（局部最优）</p>
<p><strong>Dijkstra算法：（带权有向图但权值不能为负）</strong></p>
<p>第一轮：循环遍历所有节点，找到还没有确定的最短路径，确定最短路径，</p>
<p>第二轮：然后检查所有邻接上一轮节点的顶点，找到最短路径。</p>
<p>重复一，二轮，直到找到最短路径。</p>
<h3 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h3><p>顺序查找：</p>
<p>折半查找：有序顺序表（有随机访问的特性）</p>
<p>分块查找：块内无序，块间有序。</p>
<p>B树：</p>
<ol>
<li><p>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</p>
</li>
<li><p>任何一个关键字出现且只出现在一个结点中；</p>
</li>
</ol>
<ol start="3">
<li><p>搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；</p>
</li>
<li><p>在关键字全集内做一次查找,性能逼近二分查找；</p>
</li>
</ol>
<p><img src="/"></p>
<p>B+树：</p>
<ol>
<li><p>所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)</p>
</li>
<li><p><strong>为所有叶子结点增加了一个链指针</strong></p>
</li>
</ol>
<p><img src="/"></p>
<p>区别：</p>
<p>终极目的：减少磁盘IO次数</p>
<p>1**.B+树，非叶子节点不存数据，节点数据小，每次磁盘IO的时候，数据就多，相同区域，b+树有更多的key。**</p>
<p><strong>2.B+树，子节点链表，磁盘读取预读原理，多读数据，可以减少磁盘i&#x2F;o，同时可以进行范围查询.</strong></p>
<p>哈希表：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933">散列表</a>（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450">数据结构</a>。查找与插入的速度一般为O(1）。这个映射函数叫做<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/2366288">散列函数</a>，存放记录的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097">数组</a>叫做<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933">散列表</a>。</p>
<p><strong>构造函数</strong>的方法：</p>
<ul>
<li><p>除留余数法：取关键字对 p取余的值作为散列地址，</p>
</li>
<li><p>随机数法：选择一个<strong>随机函数</strong>，把关键字的随机函数值作为散列地址。</p>
</li>
<li><p>直接定址法：以关键码KEY的某个线性函数作为散列地址， 不会发生冲突。</p>
</li>
<li><p>平方取中法：当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。</p>
</li>
</ul>
<p><strong>处理冲突</strong>的方法：</p>
<ul>
<li><p>拉链法：把冲突的同义词放在一个链表里（）</p>
</li>
<li><p>开放定址法：出现冲突往下一个空的单元放置（线性探测法，平方探测法，伪随机探测法）</p>
</li>
<li><p>再散列法：</p>
</li>
</ul>
<h3 id="排序算法："><a href="#排序算法：" class="headerlink" title="排序算法："></a><strong>排序算法：</strong></h3><p>稳定的排序方法指的是，对于两个关键字相等的记录，它们在序列中的相对位置，在排序之前和经过排序之后，没有改变。</p>
<p>内部排序和外部排序：</p>
<p><img src="/"></p>
<p><img src="/"></p>
<p>不稳定的：快速排序，选择排序，希尔排序，堆排序。</p>
<p>希尔排序：先部分有序，在整体有序。希尔排序<strong>不适用于链式存储结构。</strong></p>
<p>基数排序：按个，十，百进行排序。</p>
<p>时间复杂度(nlog2n)： 快速排序（nlog2n），堆排序（1），归并排序（n），</p>
<p>时间复杂度为 O(n2)的有：直接插入排序、冒泡排序和简单选择排序。</p>
<p><strong>哪些排序算法会受初始关键字分布的影响？</strong></p>
<p>当待排记录序列按关键字<strong>顺序有序</strong>时，<strong>直接插入排序</strong>和<strong>冒泡排序</strong>能达到 **O(n)**的</p>
<p>时间杂度;而对于<strong>快速排序</strong>而言，这是最不好的情况，此时的时间性能蜕化为</p>
<p>**O(n2)**，因此是应该尽量避免的情况。</p>
<p>另外，<strong>简单选择排序</strong>、<strong>堆排序</strong>和<strong>归并排序</strong>的时间性能不随记录序列中关键字的分</p>
<p>布而改变。</p>
<h2 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h2><p>操作系统是最基本的系统软件，是最接近硬件的软件，控制和管理的软硬件资源，以合理的方式组织计算机的工作流程，方便用户使用，向上为进程提供抽象的接口，向下管理好硬件资源。操作系统作为用户与计算机硬件系统之间的接口。</p>
<h3 id="基本特征："><a href="#基本特征：" class="headerlink" title="基本特征："></a>基本特征：</h3><p><strong>并发</strong>：两个或两个以上的<strong>事物</strong>同一时间间隔内发生（宏观上同时发生，微观上串行）并行：两个或两个以上的时间的事物，同一时刻内发生（宏观上同时发生，微观上也同时发生）<strong>最基本</strong></p>
<p><strong>共享</strong>：系统中的<strong>资源可供内存中多个并发内存使</strong>用。互斥共享：一段时间允许一个临界资源访问。</p>
<p>同时访问：一段时间内允许多个<strong>进程</strong>同时访问</p>
<p><strong>虚拟</strong>：将<strong>物理上的实体</strong>变为<strong>若干逻辑上的对应物</strong>。</p>
<p><strong>异步</strong>：进程的执行走走停停，以不可知的速度向前推进。</p>
<h3 id="操作系统作为用户与计算机硬件系统之间的接口"><a href="#操作系统作为用户与计算机硬件系统之间的接口" class="headerlink" title="操作系统作为用户与计算机硬件系统之间的接口"></a>操作系统作为用户与计算机硬件系统之间的接口</h3><p><strong>命令接口</strong>：联机命令接口（用户说一句，做一句）和脱机命令接口（说一堆，做一堆）</p>
<p><strong>程序接口</strong>：程序接口由一组系统调用命令组成。</p>
<p><strong>GUI:(图形用户界面)</strong></p>
<h3 id="内核："><a href="#内核：" class="headerlink" title="内核："></a>内核：</h3><p><strong>大内核</strong>：传统的基于操作系统的内核结构，系统调用是通过程序陷入内核程序实现的，内核完成相应的服务后进行返回程序。</p>
<p><strong>微内核</strong>：内核尽可能地小，功能尽可能的少。只包含基本功能，（c&#x2F;s模式）</p>
<p><strong>区别：</strong></p>
<p>大内核操作系统将<strong>系统的主要功能作为一个紧密联系的实体</strong>，运行在核心态，具有良好的性能。</p>
<p>微内核只是将<strong>最基本的功能保留在内核中</strong>，降低了设计的复杂性。但却增大了开销。</p>
<h3 id="用户态转向核心态："><a href="#用户态转向核心态：" class="headerlink" title="用户态转向核心态："></a>用户态转向核心态：</h3><p>1） 用户程序<strong>要求操作系统的服务</strong>，即系统调用。</p>
<p>2） 发生一次中断。</p>
<p>3） 用户程序中产生了一个错误状态。</p>
<p>4） 用户程序中企图执行一条特权指令。</p>
<p>5）** 从核心态转向用户态由一条指令实现<strong>，这条指令也是特权指令。一般情况是</strong>中断返回指令**。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用:"></a><strong>系统调用:</strong></h3><ul>
<li><p>设备管理。完成<strong>设备的请求或释放，</strong>以及<strong>设备启动</strong>等功能。</p>
</li>
<li><p>文件管理。完成<strong>文件</strong>的<strong>读、写、创建及删除</strong>等功能。</p>
</li>
<li><p>进程控制。完成<strong>进程</strong>的<strong>创建、撤销、阻塞及唤醒</strong>等功能。</p>
</li>
<li><p>进程通信。完成<strong>进程</strong>之间的<strong>消息传递或信号传递</strong>等功能。</p>
</li>
<li><p><strong>内存</strong>管理。完成<strong>内存的分配、内存的保护，地址的映射，虚拟存储</strong>等功能。</p>
</li>
</ul>
<h3 id="为什么要有系统调用"><a href="#为什么要有系统调用" class="headerlink" title="为什么要有系统调用 ?"></a>为什么要有系统调用 ?</h3><p>为什么需要系统调用？主要有以下两方面原因。</p>
<p>（1）<strong>系统调用可以为用户空间提供访问硬件资源的统一接口</strong>，以至于<strong>应用程序不必去关注具体的硬件访问操作</strong>。比如，读写文件时，应用程序不用去管磁盘类型，甚至于不用关心是哪种文件系统。</p>
<p>（2）<strong>系统调用可以对系统进行保护，保证系统的稳定和安全</strong>。系统调用的存在<strong>规定了用户进程进入内核的具体方式</strong>，换句话说，用户访问内核的路径是事先规定好的，只能从规定位置进入内核，而不准许肆意跳入内核。有了这样的进入内核的统一访问路径限制才能保证内核的安全。</p>
<h3 id="处理机管理有哪些主要功能？它们的主要任务是什么？（控同通调）"><a href="#处理机管理有哪些主要功能？它们的主要任务是什么？（控同通调）" class="headerlink" title="处理机管理有哪些主要功能？它们的主要任务是什么？（控同通调）"></a>处理机管理有哪些主要功能？它们的主要任务是什么？（控同通调）</h3><p>答：处理机管理的主要功能是<strong>进程控制</strong>、<strong>进程同步</strong>、<strong>进程通信</strong>和<strong>调度</strong>。</p>
<p>（1）<strong>进程控制</strong>：为作业<strong>创建进程</strong>，并为之<strong>分配必要的资源</strong>；<strong>进程结束时撤销进程</strong>，<strong>及时回收</strong>该</p>
<p>进程所占用的<strong>各类资源</strong>；以及控制进程在运行过程中的状态转换；</p>
<p>（2）<strong>进程同步</strong>：<strong>为多个进程（含线程）的运行进行协调</strong>，协调分为进程互斥方式和进程同步方</p>
<p>式；</p>
<p>（3）<strong>进程通信</strong>：用来实现在相互合作的<strong>进程之间的信息交换</strong>；</p>
<p>（4）<strong>处理机调度</strong>：在后备队列上等待的每个作业都必须经过调度才能执行，在传统的操作系统</p>
<p>中，包括<strong>作业调度</strong>和<strong>进程调度</strong>两步：</p>
<p>①作业调度。从后备队里按照一定的算法，选择出若干个作业，为它们分配运行所需的资源（首</p>
<p>先是分配内存）。</p>
<p>②进程调度。从进程的就绪队列中，按照一定算法选出一个进程，把处理机分配给它，并为它</p>
<p>设置运行现场，使进程投入执行。</p>
<h3 id="设备管理有哪些主要功能？其主要任务是什么？（缓-分-处）"><a href="#设备管理有哪些主要功能？其主要任务是什么？（缓-分-处）" class="headerlink" title="设备管理有哪些主要功能？其主要任务是什么？（缓 分 处）"></a>设备管理有哪些主要功能？其主要任务是什么？（缓 分 处）</h3><p>答：设备管理的主要功能有<strong>缓冲管理</strong>、<strong>设备分配</strong>和<strong>设备处理</strong>。</p>
<p>设备管理的主要任务是<strong>完成用户进程提出的 I&#x2F;O请求</strong>，为<strong>用户进程</strong>分配其所需的 <strong>I&#x2F;O设备</strong>；提高 CPU和 I&#x2F;O设备的<strong>利用率</strong>；提高 I&#x2F;O设备处理速度；方便用户使用 I&#x2F;O设备。</p>
<p>（1）<strong>缓冲管理</strong>。可有效地<strong>缓和 CPU与 I&#x2F;O设备速度不匹配的矛盾</strong>，提高** CPU的利用率**，进而提高系统吞吐量；</p>
<p>（2）<strong>设备分配</strong>。设备分配的基本任务是<strong>根据用户进程的 I&#x2F;O请求</strong>、系统的现有资源情况以及按照某种设备的分配策略，为之<strong>分配其所需的设备</strong>；</p>
<p>（3）<strong>设备处理</strong>。设备处理程序又称为设备驱动程序。其基本任务是<strong>实现 CPU和设备控制器之间的通信。</strong></p>
<h3 id="文件管理有哪些主要功能？其主要任务是什么？（存储-目-读写保护）"><a href="#文件管理有哪些主要功能？其主要任务是什么？（存储-目-读写保护）" class="headerlink" title="文件管理有哪些主要功能？其主要任务是什么？（存储 目 读写保护）"></a>文件管理有哪些主要功能？其主要任务是什么？（存储 目 读写保护）</h3><p>文件管理主要功能有文件存储空间的管理、目录管理、文件的读&#x2F;写管理和保护。文件管理</p>
<p>的主要任务是对用户文件和系统文件进行管理，以方便用户使用，并保证文件的安全性。</p>
<p>（1）<strong>文件存储空间的管理</strong>。其主要任务是为<strong>每个文件分配必要的外存空间</strong>，提高外存的利用率，</p>
<p>并能有助于提高文件系统的存、取速度。</p>
<p>（2）<strong>目录管理</strong>。目录管理的主要任务是为<strong>每个文件建立其目录项</strong>，并对众多的目录项加以有效</p>
<p>的组织，以方便<strong>实现按名存取</strong>，即用户只须提供文件名便可对该文件进行存取。</p>
<p>（3）<strong>文件的读&#x2F;写管理和保护</strong>。该功能是<strong>根据用户的请求</strong>，<strong>从外存中读取数据</strong>，或将<strong>数据写入</strong></p>
<p><strong>外存</strong>，同时<strong>防止系统中的文件被非法窃取和破坏</strong>。</p>
<h3 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h3><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,有<strong>程序段、相关数据段和PCB</strong>三部分构成了<strong>进程映像（进程实体</strong>）。所谓创建进程，实质上是创建进程映像中的PCB；而撤销进程，实质上是撤销进程的PCB。指的注意的是，进程映像是静态的，进程是动态的。</p>
<ul>
<li><p>申请空白 PCB。为新进程申请获得惟一的数字标识符，并从 PCB集合中索取一个空白 PCB；</p>
</li>
<li><p>为新进程分配资源。为新进程的程序和数据以及用户栈分配必要的内存空间；</p>
</li>
<li><p>初始化进程控制块。包括初始化标识信息，初始化处理机状态信息，初始化处理机控制信息；</p>
</li>
<li><p>将新进程插入就绪队列，如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。</p>
</li>
</ul>
<p><strong>特点：</strong></p>
<p>1）** 动态性：进程是程序的一次执行，动态性是进程最基本的特征。**</p>
<p>2） <strong>并发性：至多个进程实体，同存于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征，</strong>提高资源利用率。</p>
<p>3） 独立性：指进程实体是一个能独立运行、<strong>独立获得资源和独立接收调度的独立单位</strong>。</p>
<p>4） 异步性：由于进程的相互制约，是进程具有执行的间断性。</p>
<p>5） 结构性：进程实体是由<strong>程序段、数据段</strong>和PCB三部分组成的。</p>
<h3 id="进程调度发生在什么时机呢？这与引起进程调度的原因以及进程调度的方式有关。"><a href="#进程调度发生在什么时机呢？这与引起进程调度的原因以及进程调度的方式有关。" class="headerlink" title="进程调度发生在什么时机呢？这与引起进程调度的原因以及进程调度的方式有关。"></a>进程调度发生在什么时机呢？这与引起进程调度的原因以及进程调度的方式有关。</h3><p>(1)<strong>正在执行的进程执行完毕</strong>。这时，如果不选择新的就绪进程执行，将浪费处理机资源。</p>
<p>(2)执行中进程自己调用阻塞原语将自己阻塞起来进入睡眠等状态。</p>
<p>(3)执行中进程调用了P原语操作，从而因资源不足而被阻塞；或调用了v原语操作激活了等待资源的进程队列。</p>
<p>(4)执行中进程提出I&#x2F;O请求后被阻塞。</p>
<p>(5)在分时系统中时间片已经用完。</p>
<p>(6)就绪队列中的某进程的优先级变得高于当前执行进程的优先级，从而也将引发进程调度。</p>
<h3 id="为什么PCB是进程存在的唯一标志"><a href="#为什么PCB是进程存在的唯一标志" class="headerlink" title="为什么PCB是进程存在的唯一标志"></a>为什么P<strong>CB是进程存在的唯一标志</strong></h3><p><strong>进程控制块 PCB（Process Control Block）是进程实体的一部分</strong>，是操作系统中最重要的记录型数据结构。<strong>PCB中记录了操作系统所需的、用于描述进程的当前情况以及控制进程运行的全部信息</strong>。<strong>使一个</strong>在多道程序环境下<strong>不能独立运行的程序</strong>（含数据），<strong>成为一个能独立运行的基本单位，操作系统总是通过</strong> <strong>PCB对进程进行控制</strong>，即系统是根据进程的 PCB而非其他感知到该进程的存在的。所以说，P<strong>CB是进程存在的唯一标志。</strong></p>
<h3 id="进程间通信："><a href="#进程间通信：" class="headerlink" title="进程间通信："></a><strong>进程间通信：</strong></h3><p><strong>管道：</strong></p>
<ul>
<li><p><strong>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</strong></p>
</li>
<li><p><strong>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</strong></p>
</li>
<li><p><strong>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</strong></p>
</li>
</ul>
<p><img src="/"></p>
<p><strong>消息队列：进程通过操作系统提供的发送消息和接收消息原语进行数据交换，消息队列可以实现消息的随机查询</strong>,<strong>消息不一定要以先进先出的次序读取,也可以按消息的类型读取.</strong></p>
<p><strong>共享内存(Shared memory)：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。</strong></p>
<p><strong>套接字(Sockets)：此方法主要用于在客户端和服务器之间通过网络进行通信。</strong></p>
<p><strong>信号量(Semaphores)<strong>：</strong>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。PV操作。</strong></p>
<h3 id="线程同步："><a href="#线程同步：" class="headerlink" title="线程同步："></a><strong>线程同步：</strong></h3><p>线程同步是两个或多个共享关键资源的线程的并发执行。</p>
<h3 id="试说明引起进程阻塞或被唤醒的主要事件是什么？"><a href="#试说明引起进程阻塞或被唤醒的主要事件是什么？" class="headerlink" title="试说明引起进程阻塞或被唤醒的主要事件是什么？"></a>试说明引起进程阻塞或被唤醒的主要事件是什么？</h3><p>答：有下述几类事件会引起进程阻塞或被唤醒。</p>
<p>（1）<strong>请求系统服务</strong>。当正在<strong>执行的进程请求操作系统提供服务</strong>时，由于某种原因，操作系统并</p>
<p><strong>不能立即满足该进程的要求</strong>时，该进程只能转变为阻塞状态来等待；</p>
<p>（2）<strong>启动某种操作</strong>。当<strong>进程启动某种操作</strong>后，如果该进程必须在<strong>该操作完成之后才能继续执行</strong>，</p>
<p>则必须先使该进程阻塞，以等待该操作完成；</p>
<p>（3）<strong>新数据尚未到达</strong>。对于相互合作的进程，如果其中一个进程需要先获得另一（合作）进程</p>
<p>提供的数据后才能对数据进行处理，则只要其所需数据未到达，该进程只有（等待）阻塞；</p>
<p>（4）<strong>无新工作可做</strong>。系统往往设置一些具有某特定功能的系统进程，每当这种进程完成任务后，</p>
<p>便把自己阻塞起来以等待新任务到来。</p>
<h3 id="线程管程协程的区别"><a href="#线程管程协程的区别" class="headerlink" title="线程管程协程的区别"></a>线程管程协程的区别</h3><p><strong>进程是操作系统进行资源分配和调度的一个基本单位</strong>。每个进程都有自己的<strong>独立内存空间</strong>，不同进程通过<strong>进程间通信</strong>来通信。进程<strong>上下文进程间的切换开销比较大</strong>，但相对比较<strong>稳定安全</strong>。</p>
<p>线程是<strong>CPU调度和分派的基本单位</strong>，<strong>一个进程可以拥有多个线程</strong>。线程自己基本上不拥有系统资源,只拥有少部分的资源(如<strong>程序计数器，一组寄存器和栈</strong>)。线程间通信主要通过<strong>共享内存</strong>，上下文切<strong>换很快</strong>，资源开销较少，但相比进程不够稳定<strong>容易丢失数据</strong>。</p>
<p>协程是一种<strong>用户态的轻量级线程</strong>，<strong>一个线程也可以拥有多个协程</strong>。<strong>协程的调度</strong>完全由<strong>用户控制</strong>。协程拥有自己的寄存器上下文和栈。协程的上下文切换非常快。</p>
<p><strong>管程是一种程序结构</strong>，结构内的多个子程序（对象或模块）形成的<strong>多个工作线程互斥访问共享资源</strong>。<strong>在一个时间点，最多只有一个工作线程在执行管程的某个子程序</strong>。管程实际上是定义的一种数据结构和控制进程的一些操作的集合。</p>
<h3 id="基本分页管理与基本分段管理的区别"><a href="#基本分页管理与基本分段管理的区别" class="headerlink" title="基本分页管理与基本分段管理的区别"></a>基本分页管理与基本分段管理的区别</h3><ul>
<li><strong>页是信息的物理单位</strong>，分页是为实现离散分配方式，以消减内存的外零头，提高</li>
</ul>
<p>内存的利用率；或者说，<strong>分页仅仅是由于系统管理的需要</strong>，而不是用户的需要。<strong>段是</strong></p>
<p><strong>信息的逻辑单位</strong>，它含有一组其意义相对完整的信息。<strong>分段的目的是为了能更好的满</strong></p>
<p><strong>足用户的需要。</strong></p>
<ul>
<li><strong>页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机</strong></li>
</ul>
<p><strong>器硬件实现的</strong>，因而一个系统只能有一种大小的页面。<strong>段的长度却不固定，决定于用</strong></p>
<p><strong>户所编写的程序，</strong>通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。</p>
<ul>
<li><strong>分页的作业地址空间是维一的</strong>，即单一的线性空间，程序员只须利用一个记忆</li>
</ul>
<p>符，即可表示一地址。<strong>分段的作业地址空间是二维的</strong>，程序员在标识一个地址时，既</p>
<p>需给出<strong>段名</strong>，又需给出<strong>段内地址。</strong></p>
<h3 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h3><p>死锁,是指<strong>多个进程在运行过程中因争夺资源而造成的一种僵局</strong>，当进程处</p>
<p>于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p>
<p>产生死锁的原因可归结为<strong>竞争资源引起进程死锁</strong>和<strong>进程推进顺序不当引起死锁</strong></p>
<p>两个方面。</p>
<p><strong>产生死锁的必要条件</strong></p>
<p><strong>互斥条件：在一段时间内某资源只由一个进程占用。</strong></p>
<p><strong>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</strong></p>
<p><strong>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走（只能主动释放）</strong></p>
<p><strong>循环等待： 若干个进程间形成了首尾相接循环等待资源的情况</strong></p>
<p><strong>解决死锁：</strong></p>
<ul>
<li><strong>预防死锁；</strong>四个条件中的任何一个条件都能够预防死锁的发生。</li>
</ul>
<p>破坏请求与保持条件:采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</p>
<ul>
<li><strong>避免死锁；银行家算法算法</strong></li>
</ul>
<p>主要思想是<strong>避免系统进入不安全状态</strong>，在每次进行资源分配时，它首先检查系统是否有足够的资源满足要求，如果有，则先试行分配，并对分配后的新状态进行安全性检查。如果新状态安全，则正式分配上述资源，否则拒绝分配上述资源。这样就保证系统始终处于安全状态，从而避免死锁现象的发生。</p>
<ul>
<li><p><strong>检测死锁；</strong></p>
</li>
<li><p><strong>解除死锁：</strong></p>
</li>
</ul>
<ol>
<li><p>抢占资源：从一个或多个进程中抢占足够数量的资源分配给死锁进程，以解除死锁状态。</p>
</li>
<li><p>终止（或撤销）进程：终止或撤销系统中的一个或多个死锁进程，直至打破死锁状态。</p>
</li>
</ol>
<ol start="3">
<li><p>终止所有的死锁进程。这种方式简单粗暴，但是代价很大，很有可能会导致一些已经运行了很久的进程前功尽弃。</p>
</li>
<li><p>逐个终止进程，直至死锁状态解除。</p>
</li>
</ol>
<p>其中，<strong>预防死锁最容易实现</strong>，<strong>避免死锁使资源利用率最高</strong></p>
<h3 id="解释原语："><a href="#解释原语：" class="headerlink" title="解释原语："></a>解释原语：</h3><p><strong>原语是在操作系统中调用核心层子程序的指令，一个操作中的所有动作要么全做，要么全不做。它是一个不可分割的基本单位。原子操作在管态下执行，常驻内存。原语的作用是为了实现进程的通信和控制。</strong></p>
<h3 id="调度："><a href="#调度：" class="headerlink" title="调度："></a>调度：</h3><p><strong>高级调度</strong>又称为<strong>作业调度</strong>或长程调度，其主要功能是根据某种算法，把<strong>外存上处于后备队列中的那些作业调入内存</strong>，也就是说，它的调度对象是<strong>作业</strong>。</p>
<p><strong>中级调度</strong>。中级调度又称<strong>内存调度</strong>。<strong>引入中级调度视为了提高内存利用率和系统吞吐率</strong>，为此，应使那些暂时<strong>不能运行的进程调至外存等待</strong>，把此时的进程状态称为<strong>挂起状态</strong>。当他们已具备运行条件且内存有稍有空闲时，由中级调度来决定，吧外存上那些已具备运行条件的就绪进程，在重新调入内存，并修改其状态为<strong>就绪状态</strong>，挂在就绪队列上等待。</p>
<p><strong>低级调度</strong>用于决定<strong>就绪队列中的哪个进程</strong>应获得处理机，然后再由分派程序执行把处理机分配给该进程的具体操作。通常也把低级调度称为<strong>进程调度</strong>或短程调度，它所调度的对象是<strong>进程</strong>。</p>
<h3 id="进程调度算法："><a href="#进程调度算法：" class="headerlink" title="进程调度算法："></a>进程调度算法：</h3><ul>
<li>** FIFS先来先服务调度算法**</li>
</ul>
<p>特点：算法简单，但是效率低；有利于长作业，不利于短作业；有利于CPU繁忙型作业而不利于IO繁忙型作业。</p>
<ul>
<li>** SJF短进程优先调度算法**</li>
</ul>
<p>短作业（进程）优先调度算法是指对短作业祸端进程优先调度的算法。短作业优先调度算法是从后备队列中选择一个或若干个估计运算时间最短的作业，将他们掉入内存运行。</p>
<p>SJF调度算法的缺点：</p>
<p>1） 该算法对长作业不理。</p>
<p>2） 该算法完全未考虑作业的紧迫程度</p>
<p>3） 由于作业的长短只根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意的缩短其作业的估计运行时间，致使该算法不一定能真正做到算作业优先调度。</p>
<ul>
<li><p>** 最短剩余时间优先**</p>
</li>
<li><p>** 优先级调度算法**</p>
</li>
<li><p>** 时间片轮转调度算法**</p>
</li>
</ul>
<p>时间片轮转调度算法主要适用于分时系统。</p>
<ul>
<li>&#x20;<strong>多级反馈队列调度算法</strong></li>
</ul>
<h3 id="作业调度："><a href="#作业调度：" class="headerlink" title="作业调度："></a>作业调度：</h3><ul>
<li><p>** FIFS先来先服务调度算法**</p>
</li>
<li><p>** SJF短作业优先调度算法**</p>
</li>
<li><p>** 优先级调度算法**</p>
</li>
<li><p>** 时间片轮转调度算法**</p>
</li>
<li><p>** 高响应比优先调度算法**</p>
</li>
</ul>
<p>高响应比优先调度算法主要用于作业调度。同时考虑从每个作业的等待时间和估计需要运行的时间。&#x20;</p>
<h3 id="虚拟内存调换算法："><a href="#虚拟内存调换算法：" class="headerlink" title="虚拟内存调换算法："></a>虚拟内存调换算法：</h3><p>最佳置换算法：</p>
<p>先进先出：</p>
<p>近期最少使用LRU：</p>
<p>时钟置换算法：</p>
<h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a><strong>抖动</strong></h3><p><strong>在页面置换过程中，如果出现了刚刚换出的页面又要调入内存，刚刚换入的页面要调出内存的情况，</strong>这种频繁的页面调度行为就称为抖动，原因可能是某个进程频繁访问的页面数目高于可用的内存物理块数。如果经常发生抖动，势必会造成处理机资源的浪费，大大降低系统效率。</p>
<h3 id="驻留集与工作集"><a href="#驻留集与工作集" class="headerlink" title="驻留集与工作集"></a>驻留集与工作集</h3><p>驻留集， <strong>预先</strong>给进程分配的物理块(大小等于页面)；</p>
<p>工作集， <strong>实际</strong>进程访问到的物理块。</p>
<p>驻留集大于工作集。</p>
<h3 id="磁盘调度算法："><a href="#磁盘调度算法：" class="headerlink" title="磁盘调度算法："></a>磁盘调度算法：</h3><ul>
<li><p><strong>先来先服务（FCFS）算法</strong></p>
</li>
<li><p><strong>最短寻找时间优先（SSTF）算法</strong></p>
</li>
</ul>
<p>SSTF选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道，一是每次的寻找时间最短。当然，总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比FCFS算法更好的性能。<strong>这种算法会产生饥饿现象。</strong></p>
<ul>
<li><strong>扫描（SCAN）算法又称为电梯算法</strong></li>
</ul>
<p>SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。由于磁头移动规律与电梯运行相似，故又称为电梯调度算法。SCAN算法对<strong>最扫描过的区域不公平，</strong>因此，他在访问局部性方面不如FCFS算法和SSTF算法好。</p>
<ul>
<li><strong>循环扫描（C-SCAN）算法</strong></li>
</ul>
<p>在扫面算法的基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始端而不服务任何请求。由于SCAN算法偏向于处理那些接近最里或最外的磁道的访问请求，所以使用改进型的C-SCAN算法来避免这个问题。</p>
<h3 id="Cache替换算法"><a href="#Cache替换算法" class="headerlink" title="Cache替换算法:"></a>Cache替换算法:</h3><p><strong>随机算法（RAND）:</strong></p>
<p>若Cache已满，则随机选择一块替换。</p>
<p><strong>先进先出算法（FIFO）：</strong></p>
<p>若Cache已满，则替换最先被调入Cache的块。</p>
<p><strong>近期最少使用（LRU）：</strong></p>
<p>为每一个Cache块设置一个”计数器“，<strong>用于记录每个Cache块已经多久没被访问过了</strong>。当Cache满了之后替换”计数器<strong>“最大</strong>的。</p>
<p><strong>最近不经常使用（LFU）： (近 经)</strong></p>
<p>为每一个Cache块设置一个”计数器“，<strong>用于记录每个Cache块被访问过几次</strong>。当Cache满后替换“计数值”<strong>最小</strong>的。</p>
<h3 id="Cache写策略："><a href="#Cache写策略：" class="headerlink" title="Cache写策略："></a>Cache写策略：</h3><p><strong>写命中：</strong></p>
<p><strong>写回法：</strong></p>
<ul>
<li><strong>当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此Cache块被替换时才写回主存。</strong></li>
</ul>
<p><strong>全写法：</strong></p>
<ul>
<li><strong>当CPU对Cache块写命中时，必须把数据同时写入Cache和主存中。</strong></li>
</ul>
<p><strong>写不命中：</strong></p>
<p><strong>写分配法：</strong></p>
<ul>
<li><strong>当CPU对Cache写不命中时，把主存中的块调入Cache中，仅在Cache中修改，通常搭配写回法使用。也就是发生替换时才写回主存。</strong></li>
</ul>
<p><strong>非写分配法：</strong></p>
<ul>
<li><strong>当CPU对Cache写不命中时，只写入主存，不调入Cache中。搭配全写法使用。</strong></li>
</ul>
<h3 id="物理文件是什么，其存储结构是？"><a href="#物理文件是什么，其存储结构是？" class="headerlink" title="物理文件是什么，其存储结构是？"></a>物理文件是什么，其存储结构是？</h3><p><strong>物理文件是实际存放数据的文件，就是在磁盘上具体对应的文件。</strong></p>
<p><strong>一、顺序结构</strong></p>
<p>优点：</p>
<p>1、<strong>支持顺序存取和随机存取</strong>。</p>
<p>2、<strong>顺序存取速度快</strong>。</p>
<p>3、所需的磁盘寻道次数和寻道时间最少。</p>
<p>缺点：</p>
<p>1、需要为每个文件预留若干物理块以满足文件增长的部分需要。</p>
<p>2、<strong>不利于文件插入和删除</strong>。</p>
<p><strong>二、链式结构</strong></p>
<p>优点：</p>
<p>1、<strong>提高了磁盘空间利用率</strong>，不需要为每个文件预留物理块。</p>
<p>2、<strong>有利于文件插入和删除</strong>。</p>
<p>3、<strong>有利于文件动态扩充</strong>。</p>
<p>缺点：</p>
<p>1、存取速度慢，<strong>不适于随机存取</strong>。</p>
<p>2、当物理块间的连接指针出错时，数据丢失。</p>
<p>3、更多的寻道次数和寻道时间。</p>
<p>4、<strong>链接指针占用一定的空间，降低了空间利用率</strong>。</p>
<p><strong>三、索引结构</strong></p>
<p>优点：</p>
<p>1、不需要为每个文件预留物理块。</p>
<p>2、既能<strong>顺序存取，又能随机存取</strong>。</p>
<p>3、满足了文件<strong>动态增长、插入删除</strong>的要求。</p>
<p>缺点：</p>
<p>1、较多的寻道次数和寻道时间。</p>
<p>2、<strong>索引表本身带来了系统开销</strong>。如：内外存空间，存取时间等。</p>
<p>(.c)<strong>编译</strong>成目标模块，分配逻辑地址（.obj）<strong>链接</strong>成完整逻辑地址的的装入模块(.exe)<strong>装入内存</strong></p>
<p>连续分配方式：单一连续分配，固定分配，动态分区分配（首次适应算法，循环适应算法，最佳适应算法，最坏适应算法）。</p>
<p>非连续分配：页式分配，段式分配，段页式分配。</p>
<h3 id="动态分区的分配方式："><a href="#动态分区的分配方式：" class="headerlink" title="动态分区的分配方式："></a>动态分区的分配方式：</h3><p><strong>首次适应算法</strong>：以地址递增的序列，分配内存时，从开始进行查找，找到第一个空闲的分区，开销小，方法简单，性能最好，碎片多出现在低地址空间。</p>
<p><strong>循环首次适应算法</strong>：以<strong>地址递增的序列</strong>，分配内存时，从上次查找的位置开始递增查找。查找到第一个内存分区。碎片多出现在高地址。</p>
<p><strong>最佳适应算法：按照容量递增的顺序进行分配，顺序查找到第一个满足要求的空间碎片，要对分区进行排序，形成难以利用的小碎片。</strong></p>
<p><strong>最差适应算法： 按照容量递减的顺序进行分配，顺序查找到第一个满足要求的空间碎片，要对分区进行排序，是系统缺少大的连续空间。</strong></p>
<h3 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h3><p>目前大多数操作系统都采用了<strong>多级目录结构</strong>。对于大型文件系统，通常采用三级或三级以上的多级目录结构，<strong>以提高对目录的检索速度和文件系统的性能</strong>。多级目录结构的优点是<strong>查询速度快</strong>、同时层次结构更加清晰、能够更加有效地进行文件的管理和保护。而且在<strong>不同的用户目录中</strong>，可以<strong>使用相同的文件名</strong>。不同用户还可使用不同的文件名来访问系统中的同一个共享文件。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="设备控制器的组成："><a href="#设备控制器的组成：" class="headerlink" title="设备控制器的组成："></a><strong>设备控制器的组成：</strong></h3><p>1）<strong>设备控制器与处理机的接口</strong>。该接口用于实现 <strong>CPU与设备控制器之间的通</strong></p>
<p><strong>信；</strong></p>
<p>2）<strong>设备控制器与设备的接口</strong>。在一个设备控制器上，可以<strong>连接一个或多个设备</strong>；</p>
<p>3）<strong>I&#x2F;O逻辑组成</strong>。在设备控制器中的** I&#x2F;O逻辑用于实现对设备的控制。**</p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="spooling技术："><a href="#spooling技术：" class="headerlink" title="spooling技术："></a>spooling技术：</h3><p><img src="/"></p>
<p>1)<strong>提高了 I&#x2F;O速度。</strong>从对低速 I&#x2F;O设备进行的 I&#x2F;O操作变为对<strong>输入井</strong>或<strong>输出井</strong>的</p>
<p>操作，如同脱机操作一样，提高了 I&#x2F;O速度，<strong>缓和了 CPU与低速 I&#x2F;O设备速度</strong></p>
<p><strong>不匹配的矛盾。</strong></p>
<p>2)<strong>将独占设备改造为共享设备</strong>。因为在 SPOOLing系统的系统中，实际上并没为</p>
<p>任何进程分配设备，而知识在输入井或输出井中为进程分配一个存储区和建立一</p>
<p>张 I&#x2F;O请求表。这样，便把独占设备改造为共享设备。</p>
<p>3**)实现了虚拟设备功能<strong>。</strong>多个进程同时使用一独享设备，**而对每一进程而言，都</p>
<p>认为自己独占这一设备，从而实现了设备的虚拟分配。不过，<strong>该设备是逻辑上的</strong></p>
<p><strong>设备。</strong></p>
<h3 id="引入缓冲的主要原因是什么？"><a href="#引入缓冲的主要原因是什么？" class="headerlink" title="引入缓冲的主要原因是什么？"></a>引入缓冲的主要原因是什么？</h3><p>（1）<strong>缓和 CPU与 I&#x2F;O设备间速度不匹配的矛盾</strong>。因为 CPU的运算速率远远高于 I&#x2F;O设备的速</p>
<p>率；</p>
<p>（2）<strong>减少对 CPU的中断频率，放宽对中断响应时间的限制</strong>。这样做的目的也是为了大大提高</p>
<p>其工作效率；</p>
<p>（3）<strong>提高 CPU与 I&#x2F;O设备之间的并行性</strong>。缓冲的引入可显著地提高 CPU和 I&#x2F;O设备间的并行</p>
<p>操作程度，提高系统的吞吐量和设备的利用率。</p>
<h3 id="设备独立性："><a href="#设备独立性：" class="headerlink" title="设备独立性："></a>设备独立性：</h3><p><strong>指应用程序中所使用的设备，不局限于使用某个具体的物理设备，也称为设备无</strong></p>
<p><strong>关性。</strong></p>
<p><strong>为了实现设备独立性，在设备驱动程序之上设置一层软件</strong>，称为与  设备无关的</p>
<p>I&#x2F;O软件  或  设备独立性软件。</p>
<h3 id="操作系统中-用来表示内存已被占用的数据结构是什么"><a href="#操作系统中-用来表示内存已被占用的数据结构是什么" class="headerlink" title="操作系统中 用来表示内存已被占用的数据结构是什么"></a>操作系统中 用来表示内存已被占用的数据结构是什么</h3><p>根据操作系统所使用的存储技术的不同，所使用的数据结构表也不不同？</p>
<p>在<strong>固定分区</strong>存储管理中，<strong>内存分配表</strong></p>
<p>在<strong>可变分区</strong>存储管理中，使用<strong>已分配区表和未分配区表</strong></p>
<p>在<strong>分页存储管理</strong>中，使用内存物理块表用来记录页框的状态，管理内存物理块分布</p>
<p>在<strong>段式存储管理</strong>中，使用<strong>段表管理</strong></p>
<h2 id="计算机组成原理："><a href="#计算机组成原理：" class="headerlink" title="计算机组成原理："></a><strong>计算机组成原理：</strong></h2><h3 id="冯诺依曼机和存储程序的概念？"><a href="#冯诺依曼机和存储程序的概念？" class="headerlink" title="冯诺依曼机和存储程序的概念？"></a>冯诺依曼机和存储程序的概念？</h3><p>1) 计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5 大部件组成。</p>
<p>2) 指令和数据以<strong>同等地位存储在存储器中</strong>，并可按地址寻访。</p>
<p>3) 指令和数据均用二进制代码表示。</p>
<p>4) 指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中</p>
<p>的位置。</p>
<p>5) 指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定条件下可根据运算结果或根据</p>
<p>设定的条件改变执行顺序。</p>
<p>6) 早期的冯诺依曼机以<strong>运算器为中心</strong>，输入／输出设备通过运算器与存储器传送数据。<strong>现代计算</strong></p>
<p><strong>机以存储器为中心。</strong></p>
<p>“存储程序”的概念是指将指令以<strong>代码</strong>的形式<strong>事先输入计算机的主存储器</strong>，然后按其在<strong>存储器中的</strong></p>
<p><strong>首地址</strong>执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</p>
<h3 id="半导体随机存储器？"><a href="#半导体随机存储器？" class="headerlink" title="半导体随机存储器？"></a>半导体随机存储器？</h3><p><strong>主存储器</strong>由<strong>DRAM</strong> 实现，靠处理器的那<strong>一层(Cache)</strong> 则由<strong>SRAM <strong>实现，它们都属于</strong>易失性存储</strong></p>
<p><strong>器</strong>，只要电源被切断，原来保存的信息便会丢失。而<strong>ROM</strong> 属千<strong>非易失性存储器</strong>。</p>
<p>1**.SRAM** 的工作原理</p>
<p>静态随机存储器(SRAM) 的存储元是用<strong>双稳态触发器</strong>（六晶体管MOS) 来<strong>记忆信息的</strong>，因此即使信</p>
<p>息被读出后，它仍保持其原状态而不需要再生（<strong>非破坏性牍出</strong>）。SRAM 的存取速度快，但集成</p>
<p>度低，功耗较大，所以一般用来组成高速缓冲存储器。</p>
<p>2 .DRAM 的工作原理</p>
<p><strong>动态随机存储器(DRAM) <strong>是利用存储元电路中</strong>栅极电容上的电荷</strong>来<strong>存储信息的</strong>， DRAM 的基本存储元通常只使用一个晶体管，所以它比SRAM 的密度要高很多。<strong>DRAM 电容上的电荷一般只能维1~2ms, 因此即使电源不断电，信息也会自动消失</strong>。为此，<strong>每隔一定时间必须刷新</strong>，通常取<strong>2ms</strong>, 这个时间称为刷新周期。常用的刷新方式有3 种：<strong>集中刷新</strong>、<strong>分散刷新</strong>和<strong>异步刷新</strong>。</p>
<p>3.只读存储器(ROM) 的特点</p>
<p>ROM 和RAM 都是支持随机存取的存储器，其中SRAM 和DRAM 均为易失性半导体存储器。而</p>
<p>ROM 中一旦有了信息，就不能轻易改变，即使掉电也不会丢失，它在计算机系统中是只供读出的</p>
<p>存储器。ROM 器件有两个显著的优点：</p>
<p>1) 结构简单，所以位密度比可读写存储器的高。</p>
<p>2) 具有非易失性，所以可靠性高。</p>
<h3 id="简述-CPU的主要功能？"><a href="#简述-CPU的主要功能？" class="headerlink" title="简述 CPU的主要功能？"></a>简述 CPU的主要功能？</h3><p>CPU主要有以下四方面的功能：</p>
<p>（1） <strong>指令控制</strong>：<strong>程序的顺序控制</strong>，称为指令控制。</p>
<p>（2）** 操作控制<strong>：CPU管理并产生由</strong>内存取出的每条指令的操作信号**，把各种操作信号送往相应部件，从而控制这些部件按指令的要求进行动作。</p>
<p>（3） <strong>时间控制</strong>：对<strong>各种操作实施时间上的控制</strong>，称为时间控制。</p>
<p>（4） <strong>数据加工</strong>：对<strong>数据进行算术运算和逻辑运算处</strong>理，完成数据的加工处理。</p>
<h3 id="微程序编码有哪三种方式微指令格式有哪几种微程序控制器的基本结构是怎样的哪些特点？"><a href="#微程序编码有哪三种方式微指令格式有哪几种微程序控制器的基本结构是怎样的哪些特点？" class="headerlink" title="微程序编码有哪三种方式微指令格式有哪几种微程序控制器的基本结构是怎样的哪些特点？"></a>微程序编码有哪三种方式微指令格式有哪几种微程序控制器的基本结构是怎样的哪些特点？</h3><p>答：微程序<strong>编码方式</strong>有<strong>直接表示法</strong>，<strong>编码表示法</strong>，<strong>混合表示法</strong>。微指令的<strong>格式</strong>大体分为两种：<strong>水平型微指令</strong>和<strong>垂直型微指令</strong>。微程序的控制器具有规整性、可维护性、灵活性的优点，可实现复杂指令的操作控制，使得在计算机中可以较方便的增加和修改指令，甚至可以实现其他计算机的指令。</p>
<p>它主要由<strong>控制存储器</strong>、<strong>微指令寄存器</strong>和<strong>地址转移逻辑</strong>三大部分组成。</p>
<h2 id="软件工程："><a href="#软件工程：" class="headerlink" title="软件工程："></a><strong>软件工程：</strong></h2><h3 id="软件工程模型"><a href="#软件工程模型" class="headerlink" title="软件工程模型"></a><strong>软件工程模型</strong></h3><p>常见软件工程模型如下：</p>
<ol>
<li><strong>瀑布模型</strong>：将软件生命周期中的各个活动规定为线性连接的模型，包括需求分析、设计、编</li>
</ol>
<p>码、测试、运行与维护，<strong>由前至后、相互衔接的固定顺序</strong>，如同瀑布流水逐级下落。</p>
<p>瀑布模型是以<strong>文档作为驱动</strong>、适合于<strong>软件需求很明确的软件项目的模型</strong>。</p>
<p>瀑布模型的<strong>优点</strong>：1）<strong>容易理解，管理成本低</strong>；2）强调开发的阶段性早期计划及需求调查和产品</p>
<p>测试。</p>
<p>瀑布模型的<strong>缺点</strong>：1）<strong>客户必须能够完整、正确和清晰地表达他们的需要</strong>；2）开始2个或3个阶</p>
<p>段，很难评估真正的进度；3）<strong>项目结束时，出现大量的集成和测试工作</strong>；4）<strong>需求或设计中的错</strong></p>
<p><strong>误往往只有到了项目后期才能够被发现</strong>，对于项目风险的控制能力较弱，从而导致项目常常延期</p>
<p>完成，<strong>开发费用超出预算。</strong></p>
<ol start="2">
<li><p>V模型：瀑布模型的一个变体，提供了一种<strong>验证确认活动</strong>应用于早期软件工程工作中的方法。</p>
</li>
<li><p>增量模型：融合了瀑布模型的基本成分和原型实现的迭代特征，它假设可以将<strong>需求分段为一系</strong></p>
</li>
</ol>
<p><strong>列增量产品</strong>，每一增量可以分别开发。</p>
<p><strong>使用增量模型，第1个增量往往是核心的产品</strong>。客户对每个增量的使用和评估都作为下一个增量发</p>
<p>布的新特征和功能，这个过程在<strong>每一个增量发布后不断重复，直到产生了最终的完善产品</strong>。</p>
<p>增量模型的<strong>优点</strong>：1）<strong>容易理解，管理成本低</strong>；2）强调开发的阶段性早期计划及需求调查和产品</p>
<p>测试；3）<strong>第一个可交付版本所需要的成本和时间很少</strong>；4）开<strong>发由增量表示的小系统所承担的风</strong></p>
<p><strong>险不大</strong>；5）<strong>减少用户需求的变更</strong>；6）运行增量投资，即在项目开始时，可以仅对一个或两个增</p>
<p>量投资。</p>
<p>增量模型的<strong>缺点</strong>：1）如果没有对用户的变更需求进行规划，那么产生的<strong>初始增量</strong>可能会<strong>造成后来</strong></p>
<p><strong>增量的不稳定</strong>；2）如果需求不想早期思考的那样稳定和完整，那么一些增量就可能需要重新开</p>
<p>发，重新发布；３）<strong>管理发生的成本、进度和配置的复杂性可能会超出组织的能力</strong>。</p>
<ol start="4">
<li>演化模型：<strong>是迭代的过程</strong>，软件开发人员能<strong>逐步开发出更完整的软件版本</strong>，适用于软件需求</li>
</ol>
<p><strong>缺乏准确认识的</strong>情况，典型的演化模型有<strong>原型模型</strong>和<strong>螺旋模型</strong>。</p>
<p><strong>演化模型之原型模型</strong>：是预期系统的一个可执行版本，反映了系统性的一个选定的子集，一个原型不必满足目标软件的所有约束，<strong>目的是能快速、低成本地构建原型</strong>。原型模型开始于沟通，其目的是定义软件的总体目标，标识需求，然后快速制定原型开发的计划，确定原型的目标和范围，采用快速射击的方式对其进行建模，并构建原型。根据原型的目的，可分为三种：１）<strong>探索型原型</strong>：目的是<strong>弄清目标的要求，确定所希望的特性</strong>，并探讨多种方案的可行性；２）<strong>实验型原型</strong>：<strong>目的是验证方案或算法的合理性</strong>，是在大规模开发和实现前，用于考查方案是否合适、规格说明是否可靠等；３）<strong>演化型原型</strong>：<strong>目的是将原型作为目标系统的一部分</strong>，通过对原型的多次改进，<strong>逐步将原型演化成最终的目标系统。</strong></p>
<p><strong>演化型模型之螺旋模型</strong>：<strong>将瀑布模型与演化模型结合起来</strong>，加入了两种模型均忽略的<strong>风险分析</strong>，弥补了这两种模型的不足。螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合：螺旋模型<strong>强调风险分析</strong>，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有</p>
<p>的反应。因此，该模型特别适用于庞大、复杂并且具有高风险的系统。<strong>风险驱动</strong></p>
<ol start="5">
<li><strong>喷泉模型：</strong>一种以<strong>用户需求为动力，以对象作为驱动的模型</strong>，适合于<strong>面向对象</strong>的开发方法。</li>
</ol>
<p>它克服了瀑布模型不支持软件重用和多项开发活动集成的局限性，喷泉模型使开发过程具有迭代</p>
<p>性和无间隙性。</p>
<p>优点：<strong>提高软件项目的开发效率，节省开发时间</strong>。</p>
<p>缺点：<strong>开发阶段是重叠的</strong>，开发过程中需要大量的开发人员，<strong>不利于项目的管理</strong>。需要严格的管</p>
<p>理文档，使得审核的难度加大。</p>
<h3 id="软件的两种测试方案"><a href="#软件的两种测试方案" class="headerlink" title="软件的两种测试方案"></a>软件的两种测试方案</h3><p><strong>一、按是否查看程序内部结构分为：</strong></p>
<ul>
<li><strong>黑盒测试（Black Box Testing）</strong>：黑盒测试是根据软件的规格对软件进行的测试，这类测试不考虑软件内部的运作原理，因此软件对用户来说就像一个黑盒子。简单来说，<strong>这种测试只关心输入和输出的结果</strong>，<strong>并不考虑程序的源代码</strong>。黑盒测试分为功能测试和性能测试：</li>
</ul>
<ol>
<li><p><strong>功能测试</strong>（function testing），是黑盒测试的一方面，它检查实际软件的功能是否符合用户的需求。包括逻辑功能测试、界面测试、易用性测试和兼容性测试。</p>
</li>
<li><p><strong>性能测试</strong>（performance testing），软件的性能主要有<strong>时间性能</strong>和<strong>空间性能</strong>两种。其中，时间性能主要指软件的<strong>一个具体事务的响应时间</strong>，而空间性能主要指<strong>软件运行时所消耗的系统资源</strong>。</p>
</li>
</ol>
<ul>
<li><strong>白盒测试（White Box Testing）</strong>：白盒测试是把测试对象看作一个打开的盒子。利用白盒测试法进行动态测试时，<strong>需要测试软件产品的内部结构和处理过程</strong>，不需测试软件产品的功能。与黑盒测试相反，<strong>这种测试就要研究程序里面的源代码和程序结构</strong>。</li>
</ul>
<p><strong>二、按是否运行程序分为：</strong></p>
<p>1、<strong>静态测试（static testing）</strong>：<strong>静态测试指测试不运行的部分</strong>，<strong>只是静态地检查程序代码</strong>、界面或文档可能存在的错误的过程。例如测试产品说明书，对此进行检查和审阅.。</p>
<p>2、<strong>动态测试（dynamic testing）</strong>：<strong>动态测试是指通过运行软件来检验软件的动态行为和运行结果的正确性</strong>。具体操作就是输入相应的测试数据，检查输出结果和预期结果是否相符的过程。</p>
<p><strong>三、按阶段分为：</strong></p>
<p><strong>单元测试（Unit Testing）</strong>：单元测试是最微小规模的测试，<strong>测试的是某个功能或代码块</strong>。典型地由程序员而非测试员来做，因为它需要知道内部程序设计和编码的细节知识。</p>
<p><strong>集成测试（Integration Testing）</strong>：集成测试是指<strong>一个应用系统的各个部件的联合测试</strong>，以决定他们<strong>能否在一起共同工作并没有冲突</strong>。部件可以是代码块、独立的应用、网络上的客户端或服务器端程序。这种类型的测试尤其与客户服务器和分布式系统有关。一般集成测试以前，单元测试需要完成。</p>
<p>&#x20;<strong>系统测试（System Testing）</strong>：<strong>系统测试是将整个软件系统看做一个整体进行测试</strong>，包括对功能、性能，以及软件所运行的软硬件环境进行测试。</p>
<p>** 验收测试（Accept Testing）：<strong>验收测试是</strong>基于客户或最终用户的规格书的最终测试<strong>，或基于用户一段时间的使用后，</strong>看软件是否满足客户要求**。一般从功能、用户界面、性能、业务关联性进行测试。</p>
<p><strong>回归测试（Regression testing）</strong>：<strong>回归测试是指在发生修改之后重新测试先前的测试以保证修改的正确性。</strong>理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。</p>
<h3 id="软件，软件危机，软件工程定义"><a href="#软件，软件危机，软件工程定义" class="headerlink" title="软件，软件危机，软件工程定义"></a>软件，软件危机，软件工程定义</h3><p><strong>软件定义</strong>，就是<strong>用软件去定义系统的功能，用软件给硬件赋能，实现系统运行效率和能量效率最大化</strong>；软件定义的本质就是在硬件资源数字化、标准化的基础上，通过软件编程去实现虚拟化、灵活、多样和定制化的功能，对外提供客户化的专用智能化、定制化的服务，实现应用软件与硬件的深度融合。其核心是API(Application Programming Interface)。API解除了软硬件之间的耦合关系，推动应用软件向个性化方向发展，硬件资源向标准化方向发展，系统功能向智能化方向发展。API之上，一切皆可编程；API之下，“如无必要、勿增实体”。</p>
<p><strong>软件危机</strong>是<strong>指落后的软件生产方式无法满足迅速增长的计算机软件需求</strong>，<strong>从而导致软件与维护过程中出现一系列严重问题的现象</strong>；</p>
<p><strong>软件工程</strong>是<strong>指导计算机软件开发和维护的工程学科</strong>。采用<strong>工程</strong>的<strong>概念、原理、技术和方法</strong>来<strong>开发和维护软件</strong>，把经过时间考验而证明<strong>正确的管理技术</strong>和<strong>当前能够得到的最好的技术方法结合起来</strong>，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。</p>
<h3 id="请说出uml建模的9种图"><a href="#请说出uml建模的9种图" class="headerlink" title="请说出uml建模的9种图"></a>请说出uml建模的9种图</h3><p>1、<strong>用例图</strong>：描述角色以及角色与用例之间的连接关系。说明的是谁要使用系统，以及他们使用该系统可以做些什么。一个用例图包含了多个模型元素，如系统、参与者和用例，并且显示了这些元素之间的各种关系，如泛化、关联和依赖。</p>
<p>2、<strong>类图</strong>：类图是描述系统中的类，以及各个类之间的关系的静态视图。能够让我们在正确编写代码以前对系统有一个全面的认识。类图是一种模型类型，确切的说，是一种静态模型类型。</p>
<p>3、<strong>对象图：</strong>与类图极为相似，它是类图的实例，对象图显示类的多个对象实例，而不是实际的类。它描述的不是类之间的关系，而是对象之间的关系。</p>
<p>4、<strong>活动图：</strong>描述用例要求所要进行的活动，以及活动间的约束关系，有利于识别并行活动。能够演示出系统中哪些地方存在功能，以及这些功能和系统中其他组件的功能如何共同满足前面使用用例图建模的商务需求。</p>
<p>5、<strong>状态图：</strong>描述类的对象所有可能的状态，以及事件发生时状态的转移条件。可以捕获对象、子系统和系统的生命周期。他们可以告知一个对象可以拥有的状态，并且事件(如消息的接收、时间的流逝、错误、条件变为真等)会怎么随着时间的推移来影响这些状态。一个状态图应该连接到所有具有清晰的可标识状态和复杂行为的类；该图可以确定类的行为，以及该行为如何根据当前的状态变化，也可以展示哪些事件将会改变类的对象的状态。状态图是对类图的补充。</p>
<p>6、<strong>序列图（顺序图）</strong>：序列图是用来显示你的参与者如何以一系列顺序的步骤与系统的对象交互的模型。顺序图可以用来展示对象之间是如何进行交互的。顺序图将显示的重点放在消息序列上，即强调消息是如何在对象之间被发送和接收的。</p>
<p>7、<strong>协作图：</strong>和序列图相似，显示对象间的动态合作关系。可以看成是类图和顺序图的交集，协作图建模对象或者角色，以及它们彼此之间是如何通信的。如果强调时间和顺序，则使用序列图；如果强调上下级关系，则选择协作图；这两种图合称为交互图。</p>
<p>8、<strong>构件图 （组件图）</strong>：描述代码构件的物理结构以及各种构建之间的依赖关系。用来建模软件的组件及其相互之间的关系，这些图由构件标记符和构件之间的关系构成。在组件图中，构件时软件单个组成部分，它可以是一个文件，产品、可执行文件和脚本等。</p>
<p>9、<strong>部署图 （配置图）</strong>：是用来建模系统的物理部署。例如计算机和设备，以及它们之间是如何连接的。部署图的使用者是开发人员、系统集成人员和测试人员。</p>
<h3 id="UML-中的类图有以下几种关系："><a href="#UML-中的类图有以下几种关系：" class="headerlink" title="UML 中的类图有以下几种关系："></a><strong>UML 中的类图有以下几种关系：</strong></h3><p><strong>依赖（Dependency）关系</strong>是一种使用关系，它是对象之间<strong>耦合度最弱</strong>的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。</p>
<p><strong>关联（Association）关系</strong>是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。</p>
<p><strong>聚合（Aggregation）关系</strong>是关联关系的一种，是强关联关系，是<strong>整体和部分</strong>之间的关系，是 has-a 的关系。聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在；</p>
<p><strong>组合（Composition）关系</strong>也是关联关系的一种，也表示类之间的<strong>整体与部分</strong>的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p>
<p><strong>泛化（Generalization）关系</strong>是对象之间<strong>耦合度最大</strong>的一种关系，表示<strong>一般与特殊</strong>的关系，是父类与子类之间的关系，是<strong>一种继承关系</strong>，是 is-a 的关系。在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类；</p>
<p><strong>实现（Realization）关系</strong>是<strong>接口与实现类</strong>之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具</p>
<h2 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a><strong>数据库：</strong></h2><h3 id="什么是数据（data）和数据库（database）"><a href="#什么是数据（data）和数据库（database）" class="headerlink" title="什么是数据（data）和数据库（database）?"></a>什么是数据（data）和数据库（database）?</h3><p>数据是数据库中存储的基本对象，<strong>数据库是长期存储在计算机内、有组织、</strong></p>
<p><strong>可共享的大量数据集合。</strong></p>
<p>数据库数据的三个基本特点:</p>
<ul>
<li><p><strong>永久存储</strong></p>
</li>
<li><p><strong>有组织</strong></p>
</li>
<li><p><strong>可共享</strong></p>
</li>
</ul>
<h3 id="常用的数据模型（逻辑模型）："><a href="#常用的数据模型（逻辑模型）：" class="headerlink" title="常用的数据模型（逻辑模型）："></a>常用的数据模型（逻辑模型）：</h3><p><strong>层次模型</strong>：用<strong>树型结构</strong>表示<strong>实体类型及实体间联系</strong>。</p>
<p><strong>网状模型</strong>：允许一个以上的结点无双亲；一个结点可以有多于一个的双亲；用<strong>图结构表示实体类型及实体间联系</strong>。</p>
<p><strong>关系模型</strong>：以<strong>二维表格</strong>结构来表示实体类型及实体间联系</p>
<h3 id="数据模型应包括哪三个部分？"><a href="#数据模型应包括哪三个部分？" class="headerlink" title="数据模型应包括哪三个部分？"></a>数据模型应包括哪三个部分？</h3><p>数据模型包含<strong>数据结构</strong>，<strong>数据操纵</strong>，<strong>数据的完整性约束条件</strong>三个部分。</p>
<ul>
<li><p><strong>数据结构</strong>：描述数据库的组成对象以及对象之间的联系。</p>
</li>
<li><p><strong>数据操作</strong>：是指对数据库中的各种对象（型）的实例（值）允许执行的操作的集合·，包括操作及有关的操作规则。</p>
</li>
<li><p><strong>数据的完整性约束条件</strong>是一组完整性规则。</p>
</li>
</ul>
<p>数据库系统结构为<strong>三级模式两级映像</strong>结构，对保证数据的独立性起到至关重要的作用。</p>
<h3 id="数据库设计的基本步骤有哪些？"><a href="#数据库设计的基本步骤有哪些？" class="headerlink" title="数据库设计的基本步骤有哪些？"></a><strong>数据库设计的基本步骤有哪些？</strong></h3><ul>
<li><p>&#x20;<strong>需求分析</strong>：包含<strong>数据流图</strong>和<strong>数据字典</strong>描述；最困难，最耗时</p>
</li>
<li><p>&#x20;<strong>概念结构设计</strong>：<strong>关系规范化处理</strong></p>
</li>
<li><p>&#x20;<strong>逻辑结构设计</strong>：建立<strong>索引</strong></p>
</li>
<li><p>&#x20;<strong>物理结构设计</strong>：选择<strong>存储结构</strong>、确定存取方法及路径等内容</p>
</li>
<li><p>&#x20;<strong>数据库实施</strong></p>
</li>
<li><p>&#x20;<strong>数据库运行和维护</strong></p>
</li>
</ul>
<h3 id="简述关系的三类完整性约束"><a href="#简述关系的三类完整性约束" class="headerlink" title="简述关系的三类完整性约束"></a>简述关系的三类完整性约束</h3><ul>
<li><p><strong>实体完整性：</strong>主码的属性值不能为空</p>
</li>
<li><p><strong>参照完整性：</strong>是指两个表的主关键字和外关键字的数据应一致，保证了表之间数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。</p>
</li>
<li><p><strong>用户自定义完整性：</strong>对特定关系数据库的约束条件，反映某一具体应用必须满足的语义要求。</p>
</li>
</ul>
<h3 id="锁："><a href="#锁：" class="headerlink" title="锁："></a>锁：</h3><p><strong>共享（S)锁</strong>：多个事务可<strong>封锁一个共享页</strong>；任何事务都不能修改该页； 通常是<strong>该页被读取完毕</strong>，<strong>S锁</strong>立即<strong>被释放</strong>。</p>
<p><strong>排它（X)锁：仅允许一个事务封锁此页</strong>；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到<strong>事务结束才能被释放</strong>。</p>
<p><strong>更新（U)锁：</strong>用来<strong>预定要对此页施加X锁</strong>，它允许其他事务读，但<strong>不允许再施加U锁或X锁</strong>；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放。</p>
<h3 id="主码与外码："><a href="#主码与外码：" class="headerlink" title="主码与外码："></a><strong>主码与外码：</strong></h3><p><strong>主码是一个能唯一标识一个元组的属性。</strong>在一个<strong>关系（表）中</strong>，主码不一定只有一个，但是一定要有的。因为元组，是对世界中某种事物的数据描述，而世界中各种事物，都具有唯一性，都是可以区分的。在计算机中为了描述事物的唯一性，引入了主码的概念。在一个关系中，不同元组的主码<strong>一定不能为空，且值一定要不同。</strong></p>
<p>如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。外码的值<strong>要么为空</strong>，要么<strong>为其对应的主码中的一个值</strong>。</p>
<h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><p>1）**原子性 (Atomicity)**：事务被视为不可分割的最小单元，事务的所有操作要么 全部提交成功，要么全部失败回滚。回滚可以用回滚日志来实现，回滚日志记录 着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<p>2）**一致性 (Consistency)**：数据库在事务执行前后都保持一致性状态。在一致性 状态下，所有事务对一个数据的读取结果都是相同的。&#x20;</p>
<p>3）**隔离性 (Isolation)**：一个事务所做的修改在最终提交以前，对其它事务是不 可见的。</p>
<p>4） **持久性 (Durability)**：一旦事务提交，则其所做的修改将会永远保存到数据库 中。即使系统发生崩溃，事务执行的结果也不能丢失。&#x20;</p>
<h3 id="常见的四种故障"><a href="#常见的四种故障" class="headerlink" title="常见的四种故障"></a>常见的四种故障</h3><p>** 事务内部的故障<strong>：</strong>事务内部故障可分为预期的和非预期的，其中大部分的故障都是非预期的**。预期的事务内部故障是指可以通过事务程序本身发现的事务内部故障;非预期的事务内部故障是不能由事务程序处理的，如运算溢出故障、并发事务死锁故障、违反了某些完整性限制而导致的故障等。</p>
<p><strong>系统故障：</strong>系统故障也称为软故障，是指<strong>数据库在运行过程中</strong>，<strong>由于硬件故障、数据库软件及操作系统的漏洞、突然停电情况</strong>，<strong>导致系统停止运</strong>转，所有正在运行的事务以非正常方式终止，需要系统重新启动的一类故障。这类事务<strong>不破坏数据库</strong>，但是影响正在运行的所有事务。</p>
<p><strong>介质故障</strong>：<strong>介质故障也称为硬故障</strong>，主要指数据库在运行过程中，由于<strong>磁头碰撞、磁盘损坏、强磁干扰、天灾人祸等情况</strong>，使得<strong>数据库中的数据部分或全部丢失的一类故障</strong>。</p>
<p>** 计算机病毒故障**：计算机病毒故障是一种恶意的计算机程序，它可以像病毒一样繁殖和传播，在对计算机系统造成破坏的同时也可能对数据库系统造成破坏(破坏方式以数据库文件为主)。</p>
<p>&#x20;二、四种故障的解决方法</p>
<p>&#x20;<strong>预期的事务内部故障：将事务<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%9B%9E%E6%BB%9A&spm=1001.2101.3001.7020">回滚</a>，撤销对数据库的修改</strong>。</p>
<p>&#x20;<strong>非预期的事务内部故障：强制回滚事务</strong>，在保证该事务对其他事务没有影响的条件下，利用日志文件撤销其对数据库的修改。</p>
<p>&#x20;<strong>系统故障：</strong>待计算机重新启动之后，对于未完成的事务可能写入数据库的内容，**回滚所有未完成的事务写的结果;**对于已完成的事务可能部分或全部留在缓冲区的结果，需要重做所有已提交的事务(即撤销所有未提交的事务，重做所有已提交的事务)。</p>
<p>&#x20;<strong>介质故障的软件容错：</strong>使用<strong>数据库备份及事务日志文件</strong>，<strong>通过恢复技术，恢复数据库到备份结束时的状态。</strong></p>
<p>&#x20;<strong>介质故障的硬件容错：</strong>采用<strong>双物理存储设备</strong>，使两个硬盘存储内容相同，当其中一个硬盘出现故障时，及时使用另一个备份硬盘。</p>
<p>&#x20;<strong>计算机病毒故障：</strong>使用<strong>防火墙软件防止病毒侵入</strong>，对于已感染病毒的数据库文件，使用杀毒软件进行查杀，如果杀毒软件杀毒失败，此时只能用数据库备份文件，以软件容错的方式恢复数据库文件。</p>
<p>&#x20;这四类故障虽然有所不同，<strong>但是对数据库的影响无外乎是对数据库本身的破坏或对数据库中数据的破坏，其恢复的基本原理概况起来也就是利用存储在别处的冗余数据来重建数据库中的数据。</strong></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h2><p>算法是一系列解决问题的清晰指令，对于符合一定规则的输入，能够在有限的时间内获得要求的输出。</p>
<ul>
<li><p>输入 0~多</p>
</li>
<li><p>输出 至少一个</p>
</li>
<li><p>确定性 清晰无歧义</p>
</li>
<li><p>有效性  任何步骤可以被分解</p>
</li>
<li><p>有限性 每条指令的执行次数有限</p>
</li>
</ul>
<h3 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h3><p>一个函数调用自身，栈，递归的数学模型</p>
<p><strong>把规模大的问题转化成为小的问题。</strong></p>
<p><strong>三要素：明确函数作用（干啥的），明确的终止条件（怎么结束），函数等价关系（）。</strong></p>
<p>应用场景：问题的定义是递归的（阶乘），问题的解法是递归的（汉诺塔），数据结构适合递归（数，图）</p>
<h4 id="循环比递归的效率一定高吗？"><a href="#循环比递归的效率一定高吗？" class="headerlink" title="循环比递归的效率一定高吗？"></a>循环比递归的效率一定高吗？</h4><p>循环和递归能够实现相互转换，且各自有自己的优缺点，判断谁的效率高是没有绝对的答案的。</p>
<p><strong>递归：</strong></p>
<p>优点：代码简洁清晰、容易实现</p>
<p>缺点：当递归次数很多时，<strong>需要增加额外的堆栈处理，有可能产生堆栈溢出的现象</strong></p>
<p><strong>循环：</strong></p>
<p>优点：结构简单，速度快，效率高</p>
<p>缺点：<strong>不容易理解，编写复杂代码时会比较困难</strong></p>
<h3 id="暴力法："><a href="#暴力法：" class="headerlink" title="暴力法："></a><strong>暴力法</strong>：</h3><ul>
<li><p><strong>确定变量。</strong></p>
</li>
<li><p><strong>变量的范围，设置相应的循环。</strong></p>
</li>
<li><p><strong>根据问题描述找到相应的合理的解。</strong></p>
</li>
</ul>
<p>排序（选择，冒泡）</p>
<h3 id="分治法："><a href="#分治法：" class="headerlink" title="分治法："></a><strong>分治法：</strong></h3><p>将一个难以直接解决的大问题，分解为规模<strong>较小且相同</strong>的子问题，直至这些子问题直接求解，各个击破分而治之。（递归）</p>
<p>分解，解决，合并。</p>
<p><strong>子问题相互独立</strong></p>
<p>二分搜索，快排，归并。</p>
<h3 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a><strong>动态规划：</strong></h3><ul>
<li><p><strong>多个阶段最优</strong></p>
</li>
<li><p>把解决的问题分成多个阶段或多个子问题，然后按照顺序求解各下子问题，<strong>最后一个阶段是初始问题的解。</strong></p>
</li>
<li><p><strong>分解的问题不是独立的</strong>，下一个子问题的求解是建立在上一个子阶段的求解的基础上的。</p>
</li>
<li><p>保留已解决问题的解，在需要的时候再去查找，<strong>就可以避免大量的重复计算，提升效率</strong></p>
</li>
<li><p><strong>（自底向上）</strong></p>
</li>
<li><p>0&#x2F;1背包</p>
<h3 id="贪心算法："><a href="#贪心算法：" class="headerlink" title="贪心算法："></a>贪心算法：</h3></li>
<li><p><strong>局部最优</strong></p>
</li>
<li><p>不能对所有问题达到最优解</p>
</li>
<li><p><strong>只顾眼前</strong></p>
</li>
<li><p><strong>（自顶向下）</strong></p>
</li>
<li><p>Prim krusal 哈夫曼编码 Dijkstra算法</p>
<h3 id="回溯法："><a href="#回溯法：" class="headerlink" title="回溯法："></a>回溯法：</h3></li>
<li><p>走不通就退回去。</p>
</li>
<li><p>DFS:递归 栈</p>
</li>
<li><p>BFS:队列</p>
</li>
</ul>
<p>蚁群算法。</p>
<p>将<strong>蚁群算法应用于解决优化问题的基本思路为</strong>：用蚂蚁的行走路径表示待优化问题的可行解，整个蚂蚁群体的所有路径构成待优化问题的解空间。路径较短的蚂蚁释放的信息素量较多，随着时间的推进，较短的路径上累积的信息素浓度逐渐增高，选择该路径的蚂蚁个数也愈来愈多。最终，整个蚂蚁会在正反馈的作用下集中到最佳的路径上，<strong>此时对应的便是待优化问题的最优解。</strong></p>
<p>用<strong>正反馈机制</strong>寻求最优解，这个最优解是全局最优解，</p>
<h1 id="生态环境学院"><a href="#生态环境学院" class="headerlink" title="生态环境学院"></a>生态环境学院</h1><p><strong>生态环境学院</strong>以<strong>生态文明建设战略目标</strong>为己任，致力于培养面向<strong>全球生态环境治理</strong>和<strong>人类可持续发展</strong>，具有家国情怀，服务于<strong>国家生态文明建设和人类命运共同体构建</strong>，追求卓越、引领未来的科学精英和领袖人才。</p>
<h3 id="生物多样性"><a href="#生物多样性" class="headerlink" title="生物多样性"></a>生物多样性</h3><p>生物多样性使地球充满生机，也是人类生存和发展的基础。保护生物多样性有助于维护地球家园，促进人类可持续发展。</p>
<h3 id="生态环境与软件工程怎么结合？"><a href="#生态环境与软件工程怎么结合？" class="headerlink" title="生态环境与软件工程怎么结合？"></a><strong>生态环境与软件工程怎么结合？</strong></h3><p>随着现代科技的日新月异的发展，计算机技术在环境科学和工程专业领域发挥着越来越重要的作用，对于解决一些环境科学与工程上的问题起到了不可替代的作用。</p>
<p>计算机具有处理信息快、存储容量大、可靠性高、准确性高和可以通信等5个方面特点。</p>
<p>可以进行数据预测，储存数据，</p>
<p>我会使用idea，myeclipse,vs code .</p>
<p>学习matlab.</p>
<h3 id="个人的优势"><a href="#个人的优势" class="headerlink" title="个人的优势:"></a><strong>个人的优势:</strong></h3><p>但是每天又特别忙，抗压能力强，学习能力也比较快，因为我是9月份才开始辞职好好备考的，之前的的话都是断断续续的，一般的话，我从七点起来，到晚上12点睡觉，平时学的累的话，就会出去跑跑步，释放一下自己的压力。从学校到职场的转变，让我明白了每个人都要开始承担自己身上的责任，要规划自己的未来，遇到问题不能是逃避而是想办法解决。社会竞争十分残酷，需要努力提升自己各个方面。学会了编写邮件、与人沟通的方法以及一些计算机网络的专业知识。</p>
<h3 id="生态文明："><a href="#生态文明：" class="headerlink" title="生态文明："></a><strong>生态文明：</strong></h3><p>核心：人与自然和谐共生。</p>
<p>面对资源约束趋紧、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%8E%AF%E5%A2%83%E6%B1%A1%E6%9F%93/1298518">环境污染</a>严重、生态系统退化的严峻形势，必须树立尊重自然、顺应自然、保护自然的生态文明理念，走可持续发展道路。</p>
<p>生态文明建设其实就是把可持续发展提升到绿色发展高度，为后人“乘凉”而“种树”，就是不给后人留下遗憾而是留下更多的生态资产。生态文明建设是中国特色社会主义事业的重要内容，关系人民福祉，关乎民族未来，事关“<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%A4%E4%B8%AA%E4%B8%80%E7%99%BE%E5%B9%B4/4272808">两个一百年</a>”奋斗目标和中华民族伟大复兴<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E6%A2%A6/60483">中国梦</a>的实现。</p>
<p>山西作为全国重要的能源基地，生态环境较为脆弱，十年九旱，缺林少绿，水土流失严重，生态问题已成为制约山西经济社会发展的突出障碍，生态产品已成为全省人民群众的最高渴望。山西之长在于煤，山西之短在于水，山西之基在于林。因为过去几年我也看到了，我的家乡一直在种树，以前山上光秃秃的，现在的话，一眼看去，都是小树。最近几年生态转型，关闭了许多的小煤矿，天气质量也好转了，在我的家乡，时不时能看到国家一级保护动物黑鹳（GUAN ）,说明生态环境真的有所改善。</p>
<p>努力建设美丽中国，实现中华民族永续发展。</p>
<p>平时的话我也非常注重保护环境，出去玩的时候，一般带个垃圾袋，把留下的垃圾都装在袋子，一水多用。我父亲的话，对我影响比较大，我爸爸比较喜欢种花，每次就把淘米水，洗菜水收集起来，浇花。</p>
<h3 id="本科学习的为什么那么差？"><a href="#本科学习的为什么那么差？" class="headerlink" title="本科学习的为什么那么差？"></a><strong>本科学习的为什么那么差？</strong></h3><p>刚上了大学，好奇心比较重，就参加了社团，当了外联部部长，一直在参加活动，和拉外联举办活动。毕了业找到了工作，明白了社会竞争十分残酷，就想的考研来进一步提升自己。</p>
<h3 id="绿水青山就是金山银山？"><a href="#绿水青山就是金山银山？" class="headerlink" title="绿水青山就是金山银山？"></a><strong>绿水青山就是金山银山？</strong></h3><p>改善生态环境就是发展生产力，把生态环境优势转化为生态农业优势、生态工业优势、生态旅游优势等生态经济优势，实现更高质量、更有效率、更加公平、更可持续的发展提供了现实路径。保护环境关系到下辈人能否安居乐业。没有青山绿水，土地会沙漠化，破坏水资源。水会变少，水越来越少，人们喝水都难解决，就成了问题。</p>
<p>所以我觉得从事生态环境科研与工作的人员都很伟大。二氧化碳排放力争于2030年前达到峰值，努力争取2060年前实现碳中和。</p>
<h3 id="草地？"><a href="#草地？" class="headerlink" title="草地？"></a><strong>草地？</strong></h3><p>草原是我国重要的陆地生态系统。黄河水量的80%、长江水量的30%来源于草原地区。长期以来对草原索取多、投入少，超载过牧现象突出，加上气候变化等因素，我国大多数草原出现不同程度退化。</p>
<h3 id="知识和创新哪个重要？"><a href="#知识和创新哪个重要？" class="headerlink" title="知识和创新哪个重要？"></a>知识和创新哪个重要？</h3><ul>
<li><p>老师，这里仅仅只是我个人观点，我认为两个都很重要，有知识才会有创新，有了创新才会有知识，如果要选一个的话，我认为<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%9F%A5%E8%AF%86%E5%88%9B%E6%96%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1576748306%7D">知识创新</a>更重要。</p>
</li>
<li><p>第一因为文明的前进考的就是知识的创新，而不是知识的积累。知识不创新这个文明怎么进步，正是因为创新，才会有世界的发展，第一次工业革命，发明了蒸汽机，机器代替手工劳动。第二次工业革命，电力的广泛应用。第三次信息革命，现在的人工智能，清洁能源。</p>
</li>
<li><p>历史上的百家争鸣和<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%96%87%E8%89%BA%E5%A4%8D%E5%85%B4&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1576748306%7D">文艺复兴</a>吧！这些都是应该都是历史的长河之中，让我们的文明跳跃性发展的事件。</p>
</li>
</ul>
<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h3 id="java集合容器："><a href="#java集合容器：" class="headerlink" title="java集合容器："></a>java集合容器：</h3><p>&#x20; java中集合是一种容器，数组也是一种容器，数组作为容器优势就是效率比较高，而数组本身却不够灵活。数组的容量需要事先定义好，这就不能随着需求的变化而扩容。</p>
<p><img src="/"></p>
<p><strong>Collection（客兰客神）</strong> ：单例集合的根接口</p>
<p>一个独立的元素序列，这些元素都服从一条或多条规则。List必须按照插入的顺序保存元素，而Set不能有重复元素。Queue按照排队规则来确定对象产生的顺序。</p>
<p>List：如果是实现了List接口的集合类，具备的特点：** 有序，可重复。**</p>
<p>ArrayList： ArrayList 底层是维护了一个Object数组实现的。 特点：** 查询速度快，增删慢。**</p>
<p>LinkedList： LinkedList 底层是使用了链表数据结构实现的， 特点：** 查询速度慢，增删快。**</p>
<p>Set： 如果是实现了Set接口的集合类，具备的特点：** 无序，不可重复。**</p>
<p>HashSet：底层是使用了哈希表来支持的，特点： 存取速度快.</p>
<h3 id="JVM回收机制："><a href="#JVM回收机制：" class="headerlink" title="JVM回收机制："></a><strong>JVM回收机制：</strong></h3><p>在java中，<strong>程序员是不需要显示的去释放一个对象的内存的</strong>，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<p>一是引用计算法，他是为对象添加一个<strong>引用计数器</strong>，当对象有一个引用，计数器便加一，没有引用时减一，当为0时便没有引用，判断为垃圾。不过这种方法有局限性，有两个对象其实已经没有用了，本该回收，但这两个应用却相互引用，此时无法判断为垃圾。</p>
<p>JVM一般采用<strong>GCRoots</strong>的方法，只要从任何一个GCRoots的对象可达，就是不被回收的对象。</p>
<p><strong>Java代码编译的结果是什么？</strong></p>
<p>是字节码文件.class</p>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><h3 id="C-与python"><a href="#C-与python" class="headerlink" title="C++与python"></a>C++与python</h3><ul>
<li>C++ 是一种编译语言。C++ 编译器从 C++ 源代码生成目标代码，然后执行以生成输出。</li>
</ul>
<p>Python 是一种解释型语言。扩展名为 py 的 Python 代码不需要编译。我们可以直接将其传递给 Python 解释器并生成输出。</p>
<ul>
<li>C++ 是不可移植的，即我们需要在每个不同的平台上重新编译代码。C++主要是“一次编写，随处编译”。</li>
</ul>
<p>Python 是可移植的。它也是跨平台的，我们可以在任何平台上执行程序。</p>
<ul>
<li>C++ 程序运行得更快。Python 运行缓慢。</li>
</ul>
<h3 id="C-与JAVA"><a href="#C-与JAVA" class="headerlink" title="C++与JAVA"></a>C++与JAVA</h3><p>（1）解释对编译:<strong>Java是一种解释性语言</strong>，意味着其在执行时会被“翻译”为二进制形式，也就是java跑得时候必须有人（jvm）去解释它。<strong>而C++则是编译语言</strong>，意味着程序只能在特定操作系统上编译并在特定系统上运行，也就是说C++一步到位成机器语言的。</p>
<p>（3）性能:但如果这两个程序都足够大、而且c++的代码经过过优化，两者的速度差就会变得很显著甚至很惊人，C++会比java快很多。</p>
<p>（4）指针:指针是一种C++结构，允许您直接在内存空间中进行值管理。Java不支持指针，因此您可能使用值引用的方式进行值传递。</p>
<p>（5）重载:重载是指对某种方法或者运算符的功能进行“重新定义”。Java允许方法重载，而C++则允许进行运算符重载。</p>
<h3 id="局部变量还是全局变量"><a href="#局部变量还是全局变量" class="headerlink" title="局部变量还是全局变量"></a>局部变量还是全局变量</h3><p>局部变量：定义在函数体内部，作用域在函数体内。</p>
<p>全局变量：函数体外部的定义的变量，作用域整个程序。</p>
<p>就近原则</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="抽象："><a href="#抽象：" class="headerlink" title="抽象："></a>抽象：</h3><p><strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1">抽象</a>性是指将具有一致的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>（属性）和行为（操作）的对象<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1">抽象</a>成类。一个类就是这样一种<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1">抽象</a>，它反映了与应用有关的重要性质，而忽略其他一些无关内容。</strong></p>
<h3 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h3><p><strong>封装是指隐藏对象的属性和实现细节，仅对外提供公共访问方式，隐藏实现细节，这样可以防止外部的干扰和误用，提供公共的访问方式，使得代码模块化。</strong></p>
<h3 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h3><p><strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BB%A7%E6%89%BF%E6%80%A7">继承性</a>是子类自动共享父类<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>和方法的机制，这是类之间的一种关系。</strong></p>
<p><strong>继承就是在一个已有类的基础上派生出新类（例如动物类可以派生出狗类和猫类），子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</strong></p>
<p><strong>Java只支持单继承，不支持多继承(C++支持)，但是Java支持多层继承（继承体系）形象的说就是：儿子继承爸爸，爸爸继承爷爷，儿子可以通过爸爸继承爷爷。</strong></p>
<h3 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h3><p><strong>多态是同一个行为具有多个不同表现形式或形态的能力，例如：黑白打印机和彩色打印机相同的打印行为却有着不同的打印效果。同一操作对不同的对象，有不同解释，产生不同的执行结果。</strong></p>
<h3 id="重写与重载："><a href="#重写与重载：" class="headerlink" title="重写与重载："></a>重写与重载：</h3><p><strong>重写</strong></p>
<p><strong>在子类中把父类本身有的方法重新写一遍</strong>。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。</p>
<ul>
<li><p>发生在父类与子类之间</p>
</li>
<li><p>访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private)</p>
</li>
<li><p>方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同</p>
</li>
</ul>
<p><strong>重载</strong></p>
<p>在一个类中，同名的方法如果有不同的参数列表（<strong>参数类型不同、参数个数不同</strong>）则视为重载.</p>
<p><strong>区别:</strong></p>
<p>方法的重载和重写都是实现多态的方式，区别在于重载实现的是编译时的多态性，而重写实现的是运行时的多态性。<strong>重载</strong>发生在<strong>一个类中</strong>，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；<strong>重写发生在子类与父类之间</strong>，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，<strong>不能根据返回类型进行区分。</strong></p>
<h3 id="静态存储和动态存储："><a href="#静态存储和动态存储：" class="headerlink" title="静态存储和动态存储："></a>静态存储和动态存储：</h3><p>静态存储区主要保存 全局变量和静态变量，栈存储调用函数相关的变量、地址等，堆存储动态变量</p>
<p>静态存储在编译时对数据对象分配固定的存储位置，运行时始终不变。</p>
<p>动态存储指在运行阶段动态地为源程序中的数据对象分配存储位置。</p>
<p><strong>区别</strong></p>
<ul>
<li><p>静态内存分配在编译时完成，不占用CPU资源; 动态内存分配在运行时，分配与释放都占用CPU资源。</p>
</li>
<li><p>&#x20;静态内存在栈(stack)上分配; 动态内存在堆(heap)上分配。</p>
</li>
<li><p>&#x20;动态内存分配需要指针和引用类型支持，静态不需要。</p>
</li>
<li><p>&#x20;静态内存分配是按计划分配，由编译器负责; 动态内存分配是按需分配，由程序员负责。</p>
</li>
</ul>
<h2 id="数学："><a href="#数学：" class="headerlink" title="数学："></a>数学：</h2><h3 id="用离散数学解释下主成分分析是啥"><a href="#用离散数学解释下主成分分析是啥" class="headerlink" title="用离散数学解释下主成分分析是啥?"></a>用离散数学解释下主成分分析是啥?</h3><p>主成分分析是把<strong>各变量之间互相关联的复杂关系</strong>进行<strong>简化分析的方法</strong>。</p>
<h3 id="泰勒展开式"><a href="#泰勒展开式" class="headerlink" title="泰勒展开式"></a>泰勒展开式</h3><p>可以使用泰勒展开式的无限个多项式对某个函数求近似。泰勒公式的展开，n取到展开到直到抵消不了为止。</p>
<p><img src="/"></p>
<h3 id="C语言："><a href="#C语言：" class="headerlink" title="C语言："></a>C语言：</h3><p>getchar();吸收空格</p>
<p>gets(字符数组名)</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://glking123.github.io">Lei Lei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://glking123.github.io/2024/06/02/%E5%A4%8D%E8%AF%95/">https://glking123.github.io/2024/06/02/%E5%A4%8D%E8%AF%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://glking123.github.io" target="_blank">LeiLeiBear</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a></div><div class="post_share"><div class="social-share" data-image="/img/touxiang.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/05/31/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lei Lei</div><div class="author-info__description">Never Give Up</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/GLking123"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">希望可以对你有所帮助😊</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">多路复用技术：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">TCP&#x2F;IP 的核心思想：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">电路交换：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">报文交换：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%EF%BC%9A"><span class="toc-number">1.5.</span> <span class="toc-text">分组转发：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="toc-number">1.6.</span> <span class="toc-text">网络协议：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RARP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.7.</span> <span class="toc-text">RARP协议的工作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9A"><span class="toc-number">1.8.</span> <span class="toc-text">为什么三次握手：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9A"><span class="toc-number">1.9.</span> <span class="toc-text">为什么四次挥手：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%EF%BC%9F-x20"><span class="toc-number">1.10.</span> <span class="toc-text">何理解同步和异步？什么是同步通信和异步通信？ </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.11.</span> <span class="toc-text">流量控制的方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E5%8F%B0%E4%B8%BB%E6%9C%BA%E9%83%BD%E5%88%86%E9%85%8D%E5%94%AF%E4%B8%80%E7%9A%84IP%E5%9C%B0%E5%9D%80%E4%BA%86%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E5%9C%A8%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%EF%BC%88%E5%A6%82%E7%BD%91%E5%8D%A1%EF%BC%8C%E9%9B%86%E7%BA%BF%E5%99%A8%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%AD%89%EF%BC%89%E7%94%9F%E4%BA%A7%E6%97%B6%E5%86%85%E5%B5%8C%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E7%9A%84MAC%E5%9C%B0%E5%9D%80%E5%91%A2%EF%BC%9F%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%82%B9%EF%BC%9A"><span class="toc-number">1.12.</span> <span class="toc-text">为什么每台主机都分配唯一的IP地址了，为什么还要在网络设备（如网卡，集线器，路由器等）生产时内嵌一个唯一的MAC地址呢？主要原因有以下几点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">数据结构：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B7%E4%BD%93%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%90%97%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">数据结构具体有哪几种吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">2.2.</span> <span class="toc-text">栈与队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text">树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">2.4.</span> <span class="toc-text">图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%EF%BC%9A"><span class="toc-number">2.5.</span> <span class="toc-text">查找：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">2.6.</span> <span class="toc-text">排序算法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">操作系统：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">基本特征：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%BA%E7%94%A8%E6%88%B7%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.2.</span> <span class="toc-text">操作系统作为用户与计算机硬件系统之间的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%EF%BC%9A"><span class="toc-number">3.3.</span> <span class="toc-text">内核：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E8%BD%AC%E5%90%91%E6%A0%B8%E5%BF%83%E6%80%81%EF%BC%9A"><span class="toc-number">3.4.</span> <span class="toc-text">用户态转向核心态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.5.</span> <span class="toc-text">系统调用:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.6.</span> <span class="toc-text">为什么要有系统调用 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%EF%BC%9F%E5%AE%83%E4%BB%AC%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E6%8E%A7%E5%90%8C%E9%80%9A%E8%B0%83%EF%BC%89"><span class="toc-number">3.7.</span> <span class="toc-text">处理机管理有哪些主要功能？它们的主要任务是什么？（控同通调）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%EF%BC%9F%E5%85%B6%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E7%BC%93-%E5%88%86-%E5%A4%84%EF%BC%89"><span class="toc-number">3.8.</span> <span class="toc-text">设备管理有哪些主要功能？其主要任务是什么？（缓 分 处）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%EF%BC%9F%E5%85%B6%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E5%AD%98%E5%82%A8-%E7%9B%AE-%E8%AF%BB%E5%86%99%E4%BF%9D%E6%8A%A4%EF%BC%89"><span class="toc-number">3.9.</span> <span class="toc-text">文件管理有哪些主要功能？其主要任务是什么？（存储 目 读写保护）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%EF%BC%9A"><span class="toc-number">3.10.</span> <span class="toc-text">进程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8F%91%E7%94%9F%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E6%9C%BA%E5%91%A2%EF%BC%9F%E8%BF%99%E4%B8%8E%E5%BC%95%E8%B5%B7%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%85%B3%E3%80%82"><span class="toc-number">3.11.</span> <span class="toc-text">进程调度发生在什么时机呢？这与引起进程调度的原因以及进程调度的方式有关。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88PCB%E6%98%AF%E8%BF%9B%E7%A8%8B%E5%AD%98%E5%9C%A8%E7%9A%84%E5%94%AF%E4%B8%80%E6%A0%87%E5%BF%97"><span class="toc-number">3.12.</span> <span class="toc-text">为什么PCB是进程存在的唯一标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-number">3.13.</span> <span class="toc-text">进程间通信：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9A"><span class="toc-number">3.14.</span> <span class="toc-text">线程同步：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%95%E8%AF%B4%E6%98%8E%E5%BC%95%E8%B5%B7%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E%E6%88%96%E8%A2%AB%E5%94%A4%E9%86%92%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BA%8B%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.15.</span> <span class="toc-text">试说明引起进程阻塞或被唤醒的主要事件是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%A8%8B%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.16.</span> <span class="toc-text">线程管程协程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E7%AE%A1%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.17.</span> <span class="toc-text">基本分页管理与基本分段管理的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%EF%BC%9A"><span class="toc-number">3.18.</span> <span class="toc-text">死锁：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%8E%9F%E8%AF%AD%EF%BC%9A"><span class="toc-number">3.19.</span> <span class="toc-text">解释原语：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%EF%BC%9A"><span class="toc-number">3.20.</span> <span class="toc-text">调度：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">3.21.</span> <span class="toc-text">进程调度算法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%EF%BC%9A"><span class="toc-number">3.22.</span> <span class="toc-text">作业调度：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E8%B0%83%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">3.23.</span> <span class="toc-text">虚拟内存调换算法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8"><span class="toc-number">3.24.</span> <span class="toc-text">抖动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%BB%E7%95%99%E9%9B%86%E4%B8%8E%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-number">3.25.</span> <span class="toc-text">驻留集与工作集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">3.26.</span> <span class="toc-text">磁盘调度算法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.27.</span> <span class="toc-text">Cache替换算法:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache%E5%86%99%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="toc-number">3.28.</span> <span class="toc-text">Cache写策略：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E6%96%87%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%85%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%98%AF%EF%BC%9F"><span class="toc-number">3.29.</span> <span class="toc-text">物理文件是什么，其存储结构是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">3.30.</span> <span class="toc-text">动态分区的分配方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">3.31.</span> <span class="toc-text">目录结构：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.32.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90%EF%BC%9A"><span class="toc-number">3.33.</span> <span class="toc-text">设备控制器的组成：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-number">3.34.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spooling%E6%8A%80%E6%9C%AF%EF%BC%9A"><span class="toc-number">3.35.</span> <span class="toc-text">spooling技术：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E7%BC%93%E5%86%B2%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.36.</span> <span class="toc-text">引入缓冲的主要原因是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%EF%BC%9A"><span class="toc-number">3.37.</span> <span class="toc-text">设备独立性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD-%E7%94%A8%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%86%85%E5%AD%98%E5%B7%B2%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.38.</span> <span class="toc-text">操作系统中 用来表示内存已被占用的数据结构是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">计算机组成原理：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9C%BA%E5%92%8C%E5%AD%98%E5%82%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">冯诺依曼机和存储程序的概念？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E5%AF%BC%E4%BD%93%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">半导体随机存储器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0-CPU%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">简述 CPU的主要功能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A0%81%E6%9C%89%E5%93%AA%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">微程序编码有哪三种方式微指令格式有哪几种微程序控制器的基本结构是怎样的哪些特点？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">软件工程：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">软件工程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88"><span class="toc-number">5.2.</span> <span class="toc-text">软件的两种测试方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%EF%BC%8C%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA%EF%BC%8C%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">5.3.</span> <span class="toc-text">软件，软件危机，软件工程定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E5%87%BAuml%E5%BB%BA%E6%A8%A1%E7%9A%849%E7%A7%8D%E5%9B%BE"><span class="toc-number">5.4.</span> <span class="toc-text">请说出uml建模的9种图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UML-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9B%BE%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-number">5.5.</span> <span class="toc-text">UML 中的类图有以下几种关系：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">数据库：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%EF%BC%88data%EF%BC%89%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88database%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">什么是数据（data）和数据库（database）?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%EF%BC%88%E9%80%BB%E8%BE%91%E6%A8%A1%E5%9E%8B%EF%BC%89%EF%BC%9A"><span class="toc-number">6.2.</span> <span class="toc-text">常用的数据模型（逻辑模型）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%BA%94%E5%8C%85%E6%8B%AC%E5%93%AA%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">数据模型应包括哪三个部分？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">数据库设计的基本步骤有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E5%85%B3%E7%B3%BB%E7%9A%84%E4%B8%89%E7%B1%BB%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F"><span class="toc-number">6.5.</span> <span class="toc-text">简述关系的三类完整性约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%EF%BC%9A"><span class="toc-number">6.6.</span> <span class="toc-text">锁：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%A0%81%E4%B8%8E%E5%A4%96%E7%A0%81%EF%BC%9A"><span class="toc-number">6.7.</span> <span class="toc-text">主码与外码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9"><span class="toc-number">6.8.</span> <span class="toc-text">事物</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%95%85%E9%9A%9C"><span class="toc-number">6.9.</span> <span class="toc-text">常见的四种故障</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%EF%BC%9A"><span class="toc-number">7.1.</span> <span class="toc-text">递归：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%AF%94%E9%80%92%E5%BD%92%E7%9A%84%E6%95%88%E7%8E%87%E4%B8%80%E5%AE%9A%E9%AB%98%E5%90%97%EF%BC%9F"><span class="toc-number">7.1.1.</span> <span class="toc-text">循环比递归的效率一定高吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E6%B3%95%EF%BC%9A"><span class="toc-number">7.2.</span> <span class="toc-text">暴力法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95%EF%BC%9A"><span class="toc-number">7.3.</span> <span class="toc-text">分治法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A"><span class="toc-number">7.4.</span> <span class="toc-text">动态规划：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">7.5.</span> <span class="toc-text">贪心算法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%9A"><span class="toc-number">7.6.</span> <span class="toc-text">回溯法：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83%E5%AD%A6%E9%99%A2"><span class="toc-number"></span> <span class="toc-text">生态环境学院</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E7%89%A9%E5%A4%9A%E6%A0%B7%E6%80%A7"><span class="toc-number">0.1.</span> <span class="toc-text">生物多样性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%80%8E%E4%B9%88%E7%BB%93%E5%90%88%EF%BC%9F"><span class="toc-number">0.2.</span> <span class="toc-text">生态环境与软件工程怎么结合？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">0.3.</span> <span class="toc-text">个人的优势:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%80%81%E6%96%87%E6%98%8E%EF%BC%9A"><span class="toc-number">0.4.</span> <span class="toc-text">生态文明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E7%A7%91%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%B7%AE%EF%BC%9F"><span class="toc-number">0.5.</span> <span class="toc-text">本科学习的为什么那么差？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BF%E6%B0%B4%E9%9D%92%E5%B1%B1%E5%B0%B1%E6%98%AF%E9%87%91%E5%B1%B1%E9%93%B6%E5%B1%B1%EF%BC%9F"><span class="toc-number">0.6.</span> <span class="toc-text">绿水青山就是金山银山？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8D%89%E5%9C%B0%EF%BC%9F"><span class="toc-number">0.7.</span> <span class="toc-text">草地？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E5%92%8C%E5%88%9B%E6%96%B0%E5%93%AA%E4%B8%AA%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="toc-number">0.8.</span> <span class="toc-text">知识和创新哪个重要？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA"><span class="toc-number"></span> <span class="toc-text">JAVA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%EF%BC%9A"><span class="toc-number">0.1.</span> <span class="toc-text">java集合容器：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">0.2.</span> <span class="toc-text">JVM回收机制：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AF%94%E8%BE%83"><span class="toc-number"></span> <span class="toc-text">比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%8Epython"><span class="toc-number">0.1.</span> <span class="toc-text">C++与python</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%8EJAVA"><span class="toc-number">0.2.</span> <span class="toc-text">C++与JAVA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%BF%98%E6%98%AF%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">0.3.</span> <span class="toc-text">局部变量还是全局变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">抽象：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">封装：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">继承：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">多态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%EF%BC%9A"><span class="toc-number">1.5.</span> <span class="toc-text">重写与重载：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%92%8C%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%EF%BC%9A"><span class="toc-number">1.6.</span> <span class="toc-text">静态存储和动态存储：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">数学：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E6%98%AF%E5%95%A5"><span class="toc-number">2.1.</span> <span class="toc-text">用离散数学解释下主成分分析是啥?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">泰勒展开式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">C语言：</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/02/%E5%A4%8D%E8%AF%95/" title="复试">复试</a><time datetime="2024-06-02T03:20:52.000Z" title="发表于 2024-06-02 11:20:52">2024-06-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/31/hello-world/" title="Hello World">Hello World</a><time datetime="2024-05-31T06:14:30.586Z" title="发表于 2024-05-31 14:14:30">2024-05-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Lei Lei</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.6" zIndex="-1" count="88" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>